import bpy, inspect, pathlib, json

# -------------------------------------------------------------
# Build Add‑menu category map
# -------------------------------------------------------------
import nodeitems_builtins as nib
CATEGORY_MAP = {}
cats = getattr(nib, "_node_categories", None) \
        or getattr(nib, "node_categories_iter", lambda c: [])(bpy.context)

for cat in cats or []:
    for it in cat.items(bpy.context):
        idname = it["idname"] if isinstance(it, dict) else it.nodetype
        CATEGORY_MAP[idname] = cat.identifier

# -------------------------------------------------------------
# Socket payload (essential info only)
# -------------------------------------------------------------
def mini(sock):
    return {
        "name": sock.name,
        "idname": getattr(sock, "bl_idname", sock.__class__.__name__),
        "is_output": sock.is_output,
        "supports_field": getattr(sock, "supports_field", False),
    }

# -------------------------------------------------------------
# Collect node specs safely
# -------------------------------------------------------------
nodes = []
for name in dir(bpy.types):
    if not name.startswith("GeometryNode") or name == "GeometryNode":
        continue
    cls = getattr(bpy.types, name)
    if not (inspect.isclass(cls) and issubclass(cls, bpy.types.Node)):
        continue
    try:
        nt = bpy.data.node_groups.new("TMP", "GeometryNodeTree")
        node = nt.nodes.new(cls.bl_rna.identifier)   # may raise for abstract types
    except RuntimeError:
        bpy.data.node_groups.remove(nt, do_unlink=True)
        continue  # skip non‑instantiable classes

    nodes.append({
        "identifier": cls.bl_rna.identifier,
        "label": cls.bl_rna.name,
        "add_menu_category": CATEGORY_MAP.get(cls.bl_rna.identifier, "UNSORTED"),
        "inputs":  [mini(s) for s in node.inputs],
        "outputs": [mini(s) for s in node.outputs],
    })
    bpy.data.node_groups.remove(nt, do_unlink=True)

nodes.sort(key=lambda d: d["identifier"])

# -------------------------------------------------------------
# Write lean JSON to ~/Downloads
# -------------------------------------------------------------
out = pathlib.Path.home() / "Downloads" / "geometry_nodes_min_4_4.json"
out.write_text(json.dumps(nodes, indent=2, ensure_ascii=False))
print(f"Wrote {out}  —  {len(nodes)} instantiable nodes")
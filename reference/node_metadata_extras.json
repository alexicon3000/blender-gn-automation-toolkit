{
  "GeometryNodeSetMeshNormal": {
    "label": "Set Mesh Normal Node",
    "description": "The *Set Mesh Normal* node stores a normal vector for each mesh element.\nThis can be used to control shading appearance and influence subsequent operations that rely on surface normals.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/write/set_mesh_normal.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Remove Custom Sharpness mode",
        "description": "If enabled, removes any existing custom normals or sharpness data."
      },
      {
        "name": "Edge Sharpness Sharpness mode",
        "description": "Boolean field that defines whether an edge is marked sharp.\nTrue values result in sharp edges; false values result in smooth shading."
      },
      {
        "name": "Face Sharpness Sharpness mode",
        "description": "Boolean field that defines whether a face is marked flat.\nTrue values result in flat-shaded faces; false values result in smooth shading."
      },
      {
        "name": "Custom Normal Free mode, Tangent Space mode",
        "description": "The vector to store as the custom normal."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Mode\nStorage mode for custom normal data:\nStore the sharpness of each face or edge. Similar to the \"Shade Smooth\" and \"Shade Flat\" operators.\nStore custom normals as simple vectors in the local space of the mesh.\nThis is efficient and fast to evaluate but does not support deformation.\nStore normals in a deformation dependent custom transformation space.\nThis method is slower, but can be better when subsequent operations\nchange the mesh without handling normals specifically.\nDomain Free mode\nAttribute domain  to store free custom normals.\nStore normals per face corner, this domain is necessary to bake\nexisting mixed sharp and smooth edges into the custom normal vectors."
  },
  "GeometryNodeSetShadeSmooth": {
    "label": "Set Shade Smooth Node",
    "description": "The *Set Shade Smooth* node controls whether the mesh's faces look smooth in the viewport and renders.\nThe smooth status of both edges and faces can be controlled, corresponding to the ``sharp_edge`` and\n``sharp_face`` attributes.\nThe input node for this data is the /modeling/geometry_nodes/mesh/read/is_face_smooth.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/write/set_shade_smooth.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Shade Smooth",
        "description": "When true, the selected faces will be marked to render smooth shaded.\nOtherwise the faces will be rendered flat shaded."
      },
      {
        "name": "Selection",
        "description": "Boolean input for selecting which faces will have the Shade Smooth value applied."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Domain\nWhether to write smoothness of mesh faces or edges."
  },
  "GeometryNodeToolSetFaceSet": {
    "label": "Set Face Set Node",
    "description": "The *Set Face Set* node controls which face set that faces are in.\nThe input node for this data is the /modeling/geometry_nodes/mesh/read/face_set.\nThis node can only be used in the Tool context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/write/set_face_set.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field that controls which faces will have the Face Set value applied."
      },
      {
        "name": "Face Set",
        "description": "Integer field for specifying which face set each selected face should be moved to.\nIgnored for faces where the value of Selection is false."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "This node can only be used in the Tool context."
      }
    ]
  },
  "GeometryNodeFaceOfCorner": {
    "label": "Face of Corner Node",
    "description": "Retrieves the face that a face corner is part of.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/topology/face_of_corner.rst",
    "inputs": [
      {
        "name": "Corner Index",
        "description": "The geometry-wide index of the corner.\nIf this input is not connected, it uses the\nindex\nof the context item, which means it's important that the node is evaluated\nin the Face Corner domain."
      }
    ],
    "outputs": [
      {
        "name": "Face Index",
        "description": "The geometry-wide index of the face which the corner belongs to."
      },
      {
        "name": "Index in Face",
        "description": "The face-local index of the corner. This is 0 for the first corner of the face,\n1 for the next corner, and so on up to (number of corners - 1) for the last corner."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "If this input is not connected, it uses the"
      }
    ]
  },
  "GeometryNodeEdgesOfCorner": {
    "label": "Edges of Corner Node",
    "description": "The *Edges of Corner* node retrieves the edges on both sides of a face corner.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/topology/edges_of_corner.rst",
    "inputs": [
      {
        "name": "Corner Index",
        "description": "The index of the input face corner.\nBy default this uses the index\nfrom the field context, which makes it important that the node is evaluated on\nthe face corner domain."
      }
    ],
    "outputs": [
      {
        "name": "Next Edge Index",
        "description": "The index of the neighboring edge in the face, in the direction of increasing face corner indices."
      },
      {
        "name": "Previous Edge Index",
        "description": "The index of the neighboring edge in the face, in the direction of decreasing face corner indices."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "By default this uses the index"
      }
    ]
  },
  "GeometryNodeVertexOfCorner": {
    "label": "Vertex of Corner Node",
    "description": "Outputs the index of the vertex that a face corner is attached to.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/topology/vertex_of_corner.rst",
    "inputs": [
      {
        "name": "Corner Index",
        "description": "The index of the face corner.\nIf this input is not connected, it uses the\nindex\nof the context item, which means it's important that the node is evaluated\nin the Face Corner domain."
      }
    ],
    "outputs": [
      {
        "name": "Vertex Index",
        "description": "The index of the vertex that the face corner is attached to."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "If this input is not connected, it uses the"
      }
    ]
  },
  "GeometryNodeCornersOfVertex": {
    "label": "Corners of Vertex Node",
    "description": "Selects a neighboring face corner of a vertex and outputs its index.\nThis node is a bit special because it operates in two different domains.\nFirst, it evaluates a *Weight* for each corner in the geometry.\nThen, for each item in the context domain, it will:\n- Pick a vertex from the geometry based on the *Vertex Index*.\n- Find the face corners adjacent to this vertex.\n- Sort these corners by their associated weight.\n- Pick a corner from the above sorted list based on the *Sort Index*,\nwhere 0 means the corner with the lowest weight,\n1 means the corner with the second-lowest weight and so on.\n- Output the geometry-wide index of this corner.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/topology/corners_of_vertex.rst",
    "inputs": [
      {
        "name": "Vertex Index",
        "description": "The index of the vertex for which to find the corners.\nIf this input is not connected, it uses the\nindex\nof the context item, which means it's important that the node is evaluated\nin the Point domain."
      },
      {
        "name": "Weights",
        "description": "The weights of the corners in the geometry. Unlike the other inputs which follow\nthe context domain, this one is always evaluated in the Face Corner domain.\nThe corners are sorted by their associated weight in ascending order.\nCorners with the same weight are sorted by their index."
      },
      {
        "name": "Sort Index",
        "description": "The 0-based index of the corner to select from the vertex's sorted corners.\nIf this value is outside the range of valid indices, it wraps around."
      }
    ],
    "outputs": [
      {
        "name": "Corner Index",
        "description": "The geometry-wide index of the selected corner. You can pass this to the\n/modeling/geometry_nodes/utilities/field/evaluate_at_index or the\n/modeling/geometry_nodes/geometry/sample/sample_index (with the domain set to Face Corner)\nto retrieve details about the corner."
      },
      {
        "name": "Total",
        "description": "The number of adjacent corners, which is also the number of faces."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "If this input is not connected, it uses the"
      }
    ]
  },
  "GeometryNodeCornersOfFace": {
    "label": "Corners of Face Node",
    "description": "Selects a corner of a face and outputs its index.\nThis node is a bit special because it operates in two different domains.\nFirst, it evaluates a *Weight* for each corner in the geometry.\nThen, for each item in the context domain, it will:\n- Pick a face from the geometry based on the *Face Index*.\n- Find the corners of this face.\n- Sort these corners by their associated weight.\n- Pick a corner from the above sorted list based on the *Sort Index*,\nwhere 0 means the corner with the lowest weight,\n1 means the corner with the second-lowest weight and so on.\n- Output the geometry-wide index of this corner.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/topology/corners_of_face.rst",
    "inputs": [
      {
        "name": "Face Index",
        "description": "The index of the face for which to find the corners.\nIf this input is not connected, it uses the\nindex\nof the context item, which means it's important that the node is evaluated\nin the Face domain."
      },
      {
        "name": "Weights",
        "description": "The weights of the corners in the geometry. Unlike the other inputs which follow\nthe context domain, this one is always evaluated in the Face Corner domain.\nThe corners are sorted by their associated weight in ascending order.\nCorners with the same weight are sorted by their index."
      },
      {
        "name": "Sort Index",
        "description": "The 0-based index of the corner to select from the face's sorted corners.\nIf this value is outside the range of valid indices, it wraps around."
      }
    ],
    "outputs": [
      {
        "name": "Corner Index",
        "description": "The geometry-wide index of the selected corner. You can pass this to the\n/modeling/geometry_nodes/utilities/field/evaluate_at_index or the\n/modeling/geometry_nodes/geometry/sample/sample_index (with the domain set to Face Corner)\nto retrieve details about the corner."
      },
      {
        "name": "Total",
        "description": "The number of corners in the face, which is also its number of edges."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "If this input is not connected, it uses the"
      }
    ]
  },
  "GeometryNodeOffsetCornerInFace": {
    "label": "Offset Corner in Face Node",
    "description": "Retrieves another corner in the same face as the input corner.\nThis is like \"rotating\" the input corner around in its face.\nConceptually the operation is similar to the\n/modeling/geometry_nodes/curve/topology/offset_point_in_curve.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/topology/offset_corner_in_face.rst",
    "inputs": [
      {
        "name": "Corner Index",
        "description": "The index of the input face corner.\nIf this input is not connected, it uses the\nindex\nof the context item, which means it's important that the node is evaluated\nin the Face Corner domain."
      },
      {
        "name": "Offset",
        "description": "The number of corners to move around the face before finding the result,\ncircling back to the first corner if necessary."
      }
    ],
    "outputs": [
      {
        "name": "Corner Index",
        "description": "The index of the offset face corner."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "If this input is not connected, it uses the"
      }
    ]
  },
  "GeometryNodeCornersOfEdge": {
    "label": "Corners of Edge Node",
    "description": "Selects a neighboring face corner of an edge and outputs its index.\nThis node is a bit special because it operates in two different domains.\nFirst, it evaluates a *Weight* for each corner in the geometry.\nThen, for each item in the context domain, it will:\n- Pick an edge from the geometry based on the *Edge Index*.\n- Find *some* (not all) face corners connected to this edge -- see below.\n- Sort these corners by their associated weight.\n- Pick a corner from the above sorted list based on the *Sort Index*,\nwhere 0 means the corner with the lowest weight,\n1 means the corner with the second-lowest weight and so on.\n- Output the geometry-wide index of this corner.\nAs illustrated below, the node only looks at one corner per connected face.\nEven though the edge has four neighboring corners, *Corner Index* can only return the\nindexes of two of them, and *Total* will similarly return 2.\nYou can use the /modeling/geometry_nodes/mesh/topology/offset_corner_in_face\nto retrieve the indexes of the other corners.\nA graphic for which corners are returned for a given edge\n- Red: selected edge.\n- Blue: the corners whose index can be retrieved using this node.\n- Purple: the corners that can be retrieved by offsetting the blue corner indices using\nthe /modeling/geometry_nodes/mesh/topology/offset_corner_in_face.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/topology/corners_of_edge.rst",
    "inputs": [
      {
        "name": "Edge Index",
        "description": "The index of the edge for which to find connected corners.\nIf this input is not connected, it uses the\nindex\nof the context item, which means it's important that the node is evaluated\nin the Edge domain."
      },
      {
        "name": "Weights",
        "description": "The weights of the corners in the geometry. Unlike the other inputs which follow\nthe context domain, this one is always evaluated in the Face Corner domain.\nThe corners are sorted by their associated weight in ascending order.\nCorners with the same weight are sorted by their index."
      },
      {
        "name": "Sort Index",
        "description": "The 0-based index of the corner to select from the edge's sorted corners.\nIf this value is outside the range of valid indices, it wraps around."
      }
    ],
    "outputs": [
      {
        "name": "Corner Index",
        "description": "The geometry-wide index of the selected corner. You can pass this to the\n/modeling/geometry_nodes/utilities/field/evaluate_at_index or the\n/modeling/geometry_nodes/geometry/sample/sample_index (with the domain set to Face Corner)\nto retrieve details about the corner.\nIf the edge has no connected corners, *Corner Index* will be zero."
      },
      {
        "name": "Total",
        "description": "The number of faces (not face corners!) connected to the edge."
      }
    ],
    "notes": [
      {
        "type": "warning",
        "text": "As illustrated below, the node only looks at one corner per connected face."
      },
      {
        "type": "note",
        "text": "If this input is not connected, it uses the"
      }
    ]
  },
  "GeometryNodeEdgesOfVertex": {
    "label": "Edges of Vertex Node",
    "description": "Selects a neighboring edge of a vertex and outputs its index.\nThis node is a bit special because it operates in two different domains.\nFirst, it evaluates a *Weight* for each edge in the geometry.\nThen, for each item in the context domain, it will:\n- Pick a vertex from the geometry based on the *Vertex Index*.\n- Find the edges connected to this vertex.\n- Sort these edges by their associated weight.\n- Pick an edge from the above sorted list based on the *Sort Index*,\nwhere 0 means the edge with the lowest weight,\n1 means the edge with the second-lowest weight and so on.\n- Output the geometry-wide index of this edge.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/topology/edges_of_vertex.rst",
    "inputs": [
      {
        "name": "Vertex Index",
        "description": "The index of the vertex for which to find the edges.\nIf this input is not connected, it uses the\nindex\nof the context item, which means it's important that the node is evaluated\nin the Point domain."
      },
      {
        "name": "Weights",
        "description": "The weights of the edges in the geometry. Unlike the other inputs which follow\nthe context domain, this one is always evaluated in the Edge domain.\nThe edges are sorted by their associated weight in ascending order.\nEdges with the same weight are sorted by their index."
      },
      {
        "name": "Sort Index",
        "description": "The 0-based index of the edge to select from the vertex's sorted edges.\nIf this value is outside the range of valid indices, it wraps around."
      }
    ],
    "outputs": [
      {
        "name": "Edge Index",
        "description": "The geometry-wide index of the selected edge. You can pass this to the\n/modeling/geometry_nodes/utilities/field/evaluate_at_index or the\n/modeling/geometry_nodes/geometry/sample/sample_index (with the domain set to Edge)\nto retrieve details about the edge.\nIf the vertex has no connected edges, *Edge Index* will be zero."
      },
      {
        "name": "Total",
        "description": "The number of edges connected to the selected vertex."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "If this input is not connected, it uses the"
      }
    ]
  },
  "GeometryNodeInputMeshEdgeAngle": {
    "label": "Edge Angle Node",
    "description": "The *Edge Angle* node calculates the angle in radians between two faces that meet at an edge.\nFor the Face, Face Corner, and Point domains,\nthe node uses simple domain interpolation to move values from the mesh's edges.\nThe output of this node depends on the density of the mesh. If there are more edges\ncloser together and the curvature of the mesh stays the same, the edge angle will\nbe different.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/edge_angle.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Unsigned Angle",
        "description": "The shortest angle in radians between two faces where they meet at an edge.\nThe range of the data is from zero to PI. Flat edges and Non-manifold\nedges have an angle of zero. An edge between two faces completely folded\nback on each other has an angle of PI, or 180 degrees.\nComputing this value is slightly faster than the signed angle, so if there is no need to distinguish\nbetween convex and concave angles, using this value can provide a performance improvement."
      },
      {
        "name": "Signed Angle",
        "description": "The signed angle in radians between two faces where they meet at an edge. Flat edges\nand Non-manifold edges have an angle of zero. Concave angles are positive and convex\nangles are negative."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "The output of this node depends on the density of the mesh. If there are more edges"
      },
      {
        "type": "tip",
        "text": "Computing this value is slightly faster than the signed angle, so if there is no need to distinguish"
      }
    ]
  },
  "GeometryNodeInputMeshEdgeVertices": {
    "label": "Edge Vertices Node",
    "description": "The *Edge Vertices* node outputs the position and index of the two vertices of each of a mesh's edges.\nThe order of the two vertices of an edge is arbitrary. In some cases it may be predictable\nbased on the internals of the algorithm that created the mesh, but in general the order should\nnot be relied upon.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/edge_vertices.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Vertex Index 1/2",
        "description": "The index of the two vertices of the edge."
      },
      {
        "name": "Position 1/2",
        "description": "The position of each of the edge's vertices.\nThis output is for convenience, it is the same as using index output to retrieve the position from the\n/modeling/geometry_nodes/utilities/field/evaluate_at_index."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "The order of the two vertices of an edge is arbitrary. In some cases it may be predictable"
      }
    ]
  },
  "GeometryNodeInputShadeSmooth": {
    "label": "Is Face Smooth Node",
    "description": "The *Is Face Smooth* node outputs true for each face of the mesh if that face\nis marked to render smooth shaded. Otherwise, if the face is marked to render as flat\nshaded, then the node outputs false.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/is_face_smooth.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Smooth",
        "description": "Boolean value that indicates whether the normals of each face corner on the final mesh\nare smoothed with normal of all adjacent faces or not."
      }
    ]
  },
  "GeometryNodeInputMeshEdgeNeighbors": {
    "label": "Edge Neighbors Node",
    "description": "The *Edge Neighbors* node outputs topology information relating to each edge of a mesh.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/edge_neighbors.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Face Count",
        "description": "The number of faces that use the edge as one of their sides.\nWhen the value is one, the edge is a non-manifold boundary edge.\nAlternatively, when the value is zero, the edge is a loose edge, not used by any faces."
      }
    ]
  },
  "GeometryNodeMeshFaceSetBoundaries": {
    "label": "Face Group Boundaries Node",
    "description": "The *Face Group Boundaries Node* finds the edges which lie on the boundaries of\nspecified regions. These edges could be used to mark seams for UV unwrapping,\nfor example.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/face_group_boundaries.rst",
    "inputs": [
      {
        "name": "Face Group ID",
        "description": "Identifier for which group of faces this face belongs to. All contiguous faces\nwith the same value are in the same region."
      }
    ]
  },
  "GeometryNodeInputMeshIsland": {
    "label": "Mesh Island Node",
    "description": "The *Mesh Island* node outputs information about separate connected regions, or \"islands\" of a mesh.\nWhenever two vertices are connected together by an edge, they are considered as part of the same island,\nand will have the same *Island Index* output.\nThis node's behavior is similar to the Select Linked operator\nin edit mode, or the *Random per Island* output of the\nGeometry shader node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/mesh_island.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Island Index",
        "description": "The index of each vertex's island. Indices are decided based on the\nlowest vertex index contained in each island."
      },
      {
        "name": "Island Count",
        "description": "The total number of mesh islands. This is a single value, and does not vary per element."
      }
    ]
  },
  "GeometryNodeInputMeshFaceArea": {
    "label": "Face Area Node",
    "description": "The *Face Area* node outputs the surface area of a mesh's faces.\nThe units are in Blender units no matter the unit system,\nequivalent to meters-squared at the default unit scale.\nFor quads and N-gons, when the face's vertices are not planar,\nthe output is not necessarily the same as the sum of every one of the face's triangles visible\nin the viewport. In this case it should only be used an approximation. In some cases,\nthe /modeling/geometry_nodes/mesh/operations/triangulate can be used to get an exact value.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/face_area.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Area",
        "description": "The surface area of each of the mesh's faces."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "For quads and N-gons, when the face's vertices are not planar,"
      }
    ]
  },
  "GeometryNodeToolFaceSet": {
    "label": "Face Set Node",
    "description": "The *Face Set Node* outputs which face set a face is in,\nand whether or not face sets exist in the mesh at all.\nThe corresponding data flow node is the /modeling/geometry_nodes/mesh/write/set_face_set.\nThis node can only be used in the Tool context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/face_set.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "This node can only be used in the Tool context."
      }
    ]
  },
  "GeometryNodeInputMeshFaceIsPlanar": {
    "label": "Is Face Planar Node",
    "description": "The *Is Face Planar* node outputs whether every triangle of a\nquads or N-gons is on the same plane as all of the others, in\nother words, if they have the same normal.\nFor example, a non-planar face can be created by moving a single vertex in a face but not\nthe others. Triangles will always be planar.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/face_is_planar.rst",
    "inputs": [
      {
        "name": "Threshold",
        "description": "The distance a point can be from the surface before the face is no longer\nconsidered planar."
      }
    ],
    "outputs": [
      {
        "name": "Planar",
        "description": "Whether each mesh face is planar."
      }
    ]
  },
  "GeometryNodeInputMeshVertexNeighbors": {
    "label": "Vertex Neighbors Node",
    "description": "The *Vertex Neighbors* node outputs topology information relating to each vertex of a mesh.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/vertex_neighbors.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Vertex Count",
        "description": "The number of vertices connected to this vertex with an edge, equal to the number of connected edges."
      },
      {
        "name": "Face Count",
        "description": "The number of faces that contain the vertex."
      }
    ]
  },
  "GeometryNodeInputShortestEdgePaths": {
    "label": "Shortest Edge Paths Node",
    "description": "The *Shortest Edge Paths* node finds paths along mesh edges to a selection of end vertices.\nThe cost used to define \"shortest\" can be set to anything. By default there is a constant cost\nfor every edge, but a typical input would be the length of each edge.\nThe output is encoded with vertex indices, and is meant to be used on the vertex domain.\nFor each vertex, the *Next Vertex Index* output gives the index of the following vertex\nin the path to the \"closest\" endpoint.\nThe node is implemented with `Dijkstra's algorithm <https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>`__.\nThe edge length is a natural input to the *Edge Cost*. It can be implemented with the\n/modeling/geometry_nodes/mesh/read/edge_vertices and the\n/modeling/geometry_nodes/utilities/vector/vector_math set to the *Distance* operation.\nThis node can be used with the /modeling/geometry_nodes/mesh/operations/edge_paths_to_selection\nor the /modeling/geometry_nodes/mesh/operations/edge_paths_to_curves to generate new geometry\nbased on the paths.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/shortest_edge_paths.rst",
    "inputs": [
      {
        "name": "End Vertex",
        "description": "A selection of the goal vertices that terminate the edge paths."
      },
      {
        "name": "Edge Cost",
        "description": "The weight for each edge, used to determine the meaning of \"shortest.\""
      }
    ],
    "outputs": [
      {
        "name": "Next Vertex Index",
        "description": "The following vertex on the shortest path from every vertex to the closest endpoint\n(as defined by the cost input)."
      },
      {
        "name": "Total Cost",
        "description": "The remaining cost before an end vertex is reached."
      }
    ]
  },
  "GeometryNodeInputEdgeSmooth": {
    "label": "Is Edge Smooth Node",
    "description": "The *Is Edge Smooth* node outputs true for each edge of the mesh that is *not* marked as sharp. Otherwise, if the edge\n*is* marked as sharp, then the node outputs false.\nMark Sharp & Clear Sharp",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/is_edge_smooth.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Smooth",
        "description": "Boolean value that indicates whether the edges of the mesh are *not* marked as sharp."
      }
    ]
  },
  "GeometryNodeEdgesToFaceGroups": {
    "label": "Edges to Face Groups Node",
    "description": "The *Edges to Face Groups* node group faces into regions surrounded by the selected boundary edges.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/edges_to_face_groups.rst",
    "inputs": [
      {
        "name": "Boundary Edges",
        "description": "Edges used to split faces into separate groups."
      }
    ],
    "outputs": [
      {
        "name": "Face Group ID",
        "description": "Index of the face group inside each boundary edge region."
      }
    ]
  },
  "GeometryNodeInputMeshFaceNeighbors": {
    "label": "Face Neighbors Node",
    "description": "The *Face Neighbors* node outputs topology information relating to each face of a mesh.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/read/face_neighbors.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Vertex Count",
        "description": "This output is simply the number of sides of each face, or how many corners each face has."
      },
      {
        "name": "Neighboring Face Count",
        "description": "The number of faces that connect to this face with at least one edge. On a regular manifold\nmesh with only quads and triangles, this will be the same as the vertex count, otherwise it might\nbe completely different."
      }
    ]
  },
  "GeometryNodeMeshToPoints": {
    "label": "Mesh to Points Node",
    "description": "The *Mesh to Points* node generates a point cloud from a mesh.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/mesh_to_points.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard Mesh input."
      },
      {
        "name": "Selection",
        "description": "The meshes used to generate a point cloud."
      },
      {
        "name": "Position",
        "description": "Positions of generated points. By default, this input is the same as\nif the /modeling/geometry_nodes/geometry/read/position was connected."
      },
      {
        "name": "Radius",
        "description": "Radii of generated points."
      }
    ],
    "outputs": [
      {
        "name": "Points",
        "description": "Generated point cloud."
      }
    ],
    "properties": "Mode\nPoints are generated for each vertex.\nPoints are generated for each edge, at the middle of each edge, by default.\nPoints are generated for each face, at the average of all of each face's vertices, by default.\nPoints are generated for each corner. The points are all placed at the location of each\ncorners vertex, so they will overlap by default."
  },
  "GeometryNodeScaleElements": {
    "label": "Scale Elements Node",
    "description": "Scales the selected faces or edges, letting you specify a scaling factor and pivot point for each one.\nConnected faces/edges are scaled together using their average factor and pivot point.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/scale_elements.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field indicating which elements to scale."
      },
      {
        "name": "Scale",
        "description": "The scaling factor for each element."
      },
      {
        "name": "Center",
        "description": "The pivot point for each element."
      },
      {
        "name": "Axis Single Axis Mode Only",
        "description": "Axis along which to scale each element. This vector is normalized internally, so the length does not matter."
      },
      {
        "name": "Scale Mode",
        "description": ""
      }
    ],
    "properties": "Domain\nThe element type to transform."
  },
  "GeometryNodeEdgePathsToSelection": {
    "label": "Edge Paths to Selection Node",
    "description": "The *Edge Paths to Selection* node follows paths across mesh edges and outputs a selection\nof every visited edge.\nThis node is meant to use the output of the /modeling/geometry_nodes/mesh/read/shortest_edge_paths.\nIt can be combined with the /modeling/geometry_nodes/geometry/operations/separate_geometry to remove\nany unused edges.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/edge_paths_to_selection.rst",
    "inputs": [
      {
        "name": "Start Vertices",
        "description": "A selection of the vertices to start at when traveling along the next vertex indices."
      },
      {
        "name": "Next Vertex Index",
        "description": "Describes the path to follow at every vertex."
      }
    ],
    "outputs": [
      {
        "name": "Selection",
        "description": "A boolean field indicating all edges visited when traversing the mesh."
      }
    ]
  },
  "GeometryNodeMeshToCurve": {
    "label": "Mesh to Curve Node",
    "description": "The *Mesh to Curve* node converts a mesh into one or more curve splines.\nTwo different conversion modes are supported, depending on the desired output:\n- Edges: Turns each string of connected mesh edges into a poly spline.\nWhenever two or more edge strings intersect, they will be split into separate splines.\n- Faces: Creates a cyclic spline from each mesh face. This mode is generally much faster than *Edges*,\nas it parallelizes easily and can share face and corner attributes without needing to copy them.\nLoose vertices are ignored -- they will not be turned into single-point splines.\nAttributes, both named and unnamed ones, are transferred to the resulting splines.\nIf there is a ``radius`` attribute, it will be applied as such,\nalthough you may find it more convenient to use the\n/modeling/geometry_nodes/curve/write/set_curve_radius for this.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/mesh_to_curve.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard mesh input."
      },
      {
        "name": "Selection",
        "description": "A field input evaluated on the edge domain to determine whether each edge will be included in the result.\nUsing this input is more efficient than deleting parts of the geometry before or after the conversion."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Generated curve."
      }
    ],
    "properties": "Mode\nDetermines how the mesh is converted to curves:",
    "notes": [
      {
        "type": "tip",
        "text": "Using this input is more efficient than deleting parts of the geometry before or after the conversion."
      }
    ]
  },
  "GeometryNodeFlipFaces": {
    "label": "Flip Faces Node",
    "description": "The *Flip Faces Node* reverses the order of the vertices and edges of each selected face.\nThe most common use of this node is to flip the normals of a face.\nAny face corner domain attributes of selected faces are also reversed.\nThough this node is usually used to affect normals, it is not called \"Flip Normals\" for an important reason.\nThe node does not actually interact with normals directly. Normals are defined by the\n`right hand rule <https://en.wikipedia.org/wiki/Right-hand_rule#Curve_orientation_and_normal_vectors>`__,\nso if a face's vertex list is reversed, then its normal will point in the opposite direction.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/flip_faces.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Whether to flip the direction of each face.\nTrue values mean the face will be flipped, false means the face will be unaffected."
      }
    ]
  },
  "GeometryNodeMeshBoolean": {
    "label": "Mesh Boolean Node",
    "description": "The *Mesh Boolean Node* allows you to cut, subtract, and join the geometry of two inputs.\nThis node offers the same operations as the Boolean modifier.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/mesh_boolean.rst",
    "inputs": [
      {
        "name": "Mesh 1/2",
        "description": "Standard geometry input."
      },
      {
        "name": "Self Intersection Exact Solver",
        "description": "Correctly calculates cases when one or both operands have self-intersections.\nThis involves more calculations making the node slower."
      },
      {
        "name": "Hole Tolerant Exact Solver",
        "description": "Optimizes the Boolean output for Non-manifold geometry\nat the cost of increased computational time.\nBecause of the performance impact, this option should only be enabled\nwhen the solver demonstrates errors with non-manifold geometry."
      }
    ],
    "properties": "Operation\nProduce a new geometry containing only the volume inside of both geometry 1 and geometry 2.\nThe two input meshes are joined, then any interior elements are removed.\nGeometry 2 is subtracted from geometry 1 (everything outside of geometry 2 is kept).\nSolver\nAlgorithm used to calculate the Boolean intersections.\nUses a mathematically simple solver which offers the good performance;\nhowever, this solver lacks support for overlapping geometry.\nUses a mathematically complex solver which offers the best results\nwhen there are coplanar faces or other overlapping geometry;\nhowever, this solver is much slower.\nUses a solver that is usually fastest but only works on Manifold meshes,\n(plus the special case of Difference with a plane)."
  },
  "GeometryNodeEdgePathsToCurves": {
    "label": "Edge Paths to Curves Node",
    "description": "The *Edge Paths to Curves* node output curves that follow paths across mesh edges.\nThis node is meant to use the output of the /modeling/geometry_nodes/mesh/read/shortest_edge_paths.\nIt is similar to the /modeling/geometry_nodes/mesh/operations/edge_paths_to_selection, but it creates\na curve that follow each path, rather than a selection of every visited edge.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/edge_paths_to_curves.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard mesh input."
      },
      {
        "name": "Start Vertices",
        "description": "A selection of the vertices to start at when traveling along the next vertex indices."
      },
      {
        "name": "Next Vertex Index",
        "description": "Describes the path to follow at every vertex."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard curves output."
      }
    ]
  },
  "GeometryNodeMeshToVolume": {
    "label": "Mesh to Volume Node",
    "description": "The *Mesh to Volume* node creates a fog volumes based on the shape of a mesh.\nThe volume is created with a grid of the name ``\"density\"``.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/mesh_to_volume.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard Mesh input."
      },
      {
        "name": "Density",
        "description": "Value of voxels inside the generated fog volume."
      },
      {
        "name": "Resolution Mode",
        "description": "How the voxel size is specified.\nSpecify the approximate number of voxels along the diagonal.\nSpecify the voxel side length. It is recommended to be careful when tweaking this value,\nbecause small changes can have a large effect on the processing time."
      },
      {
        "name": "Voxel Amount Amount",
        "description": "Specify the approximate number of voxels along the diagonal."
      },
      {
        "name": "Voxel Size Size",
        "description": "Specify the voxel side length."
      },
      {
        "name": "Interior Band Width",
        "description": "The maximum distance of the included voxels to the surface on the inside of the mesh."
      }
    ],
    "outputs": [
      {
        "name": "Volume",
        "description": "The generated volume grid."
      }
    ]
  },
  "GeometryNodeSplitEdges": {
    "label": "Split Edges Node",
    "description": "Like the /modeling/modifiers/generate/edge_split, the *Split Edges* node splits and duplicates edges\nwithin a mesh, breaking 'links' between faces around those split edges.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/split_edges.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "A standard Boolean selection input to determine which edges will be split."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Because of mesh topology requirements, sometimes more or fewer edges than are selected will be split."
      }
    ]
  },
  "GeometryNodeMeshToDensityGrid": {
    "label": "Mesh to Density Grid Node",
    "description": "The *Mesh to Density Grid* node converts a mesh into a density grid, where\neach voxel stores a scalar value representing how far it lies inside or near\nthe surface of the mesh. This can be used to generate fog volumes, soft-body\nrepresentations, or as input to volumetric and field-based effects.\nThe resulting grid contains smooth gradients that transition from high values\ninside the mesh to low values outside, allowing for continuous blending and\nsampling operations.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/mesh_to_density_grid.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "The input mesh to be converted into a density grid.\nThe mesh defines the surface that will be voxelized."
      },
      {
        "name": "Density",
        "description": "The scalar value assigned to voxels inside the mesh.\nTypically a value of ``1.0`` for full density and ``0.0`` for empty space,\nthough any scalar range can be used to represent material thickness or opacity."
      },
      {
        "name": "Voxel Size",
        "description": "The size of each voxel in object space units.\nSmaller values produce higher-resolution grids with more detail, while\nlarger values reduce detail but improve performance and memory efficiency."
      },
      {
        "name": "Gradient Width",
        "description": "The width of the gradient region inside the mesh.\nControls how smoothly the density falls off from the interior toward the\nexterior. Larger values create a broader transition, while smaller values\nproduce a sharper surface boundary."
      }
    ],
    "outputs": [
      {
        "name": "Density Grid",
        "description": "The resulting float grid representing the density of the mesh.\nVoxels inside the mesh will have higher density values, while voxels\noutside the mesh will approach zero. The smooth transition is defined by\nthe *Gradient Width* parameter."
      }
    ]
  },
  "GeometryNodeSubdivideMesh": {
    "label": "Subdivide Mesh Node",
    "description": "The *Subdivide Mesh* node adds new faces to mesh geometry using a simple interpolation for deformation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/subdivide_mesh.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Level",
        "description": "The number of subdivisions to apply to the input geometry."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeTriangulate": {
    "label": "Triangulate Node",
    "description": "The *Triangulate* node converts all faces in a mesh (quads and n-gons) to triangular faces.\nIt functions the same as the Triangulate tool in Edit Mode.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/triangulate.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "A standard Boolean selection input to determine which faces will be triangulated."
      },
      {
        "name": "Quad Method",
        "description": "Split the quads in nice triangles, slower method.\nSplit the quads on their 1st and 3rd vertices.\nSplit the quads on their 2nd and 4th vertices.\nSplit the quads along their shortest diagonal.\nSplit the quads along their longest diagonal. This is the preferred mode for cloth simulations."
      },
      {
        "name": "N-gon Method",
        "description": "Arrange the new triangles nicely, slower method.\nSplit n-gons using an ear-clipping algorithm\n(the same method of tessellation used for viewport display)."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeExtrudeMesh": {
    "label": "Extrude Mesh Node",
    "description": "The *Extrude Mesh Node* generates new edges or faces on the selected geometry elements\nand moves them by a certain offset.\nThe operations are similar to the extrude tools\nin mesh edit mode, though there are some differences. Most importantly, the node never keeps the back-faces\nof the extrusion in place, they are always removed. Attribute propagation rules may also be different.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/extrude_mesh.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "A boolean field indicating which elements should be extruded."
      },
      {
        "name": "Offset",
        "description": "The translation vector for each extruded element. By default, this is the element's\nnormal.\nIf all the elements are extruded in the same direction, you may be able to improve performance\nby connecting a /modeling/geometry_nodes/input/constant/vector to this input,\nthereby skipping the normal calculation."
      },
      {
        "name": "Offset Scale",
        "description": "Scaling factor for the above translation vector."
      },
      {
        "name": "Individual Face Mode Only",
        "description": "Whether to extrude each face individually rather than extruding connected groups of faces together."
      }
    ],
    "properties": "Mode\nAttaches a new freestanding edge to each selected vertex.\nAttaches a new quad face to each selected edges. Vertices shared by the\noriginal selected edges are also shared in the duplicated edges.\nDepending on the situation, the normals of the new faces may be arbitrary. If the selected\nedges each have only one connected face, then the node can pick a consistent orientation for the\nnew faces, but if there is more than one connected face, or no connected faces, the normals\nmay have to be adjusted afterwards.\nExtrudes contiguous regions of selected faces, or each selected face individually,\ndepending on the *Individual* boolean input.\nWhen the *Individual* input is false, the node will find regions of connected faces and generate\nnew \"side\" faces on the boundaries of those regions. Any vertices, edges or faces on the *inside*\nof the regions simply are moved, not duplicated. If the whole mesh is selected and it is already\na Manifold shape, then the result will just be that the whole mesh gets resized.",
    "notes": [
      {
        "type": "tip",
        "text": "If all the elements are extruded in the same direction, you may be able to improve performance"
      },
      {
        "type": "note",
        "text": "Depending on the situation, the normals of the new faces may be arbitrary. If the selected"
      }
    ]
  },
  "GeometryNodeMeshToSDFGrid": {
    "label": "Mesh to SDF Grid Node",
    "description": "The *Mesh to SDF Grid* node converts a mesh into a Signed Distance Field (SDF)\ngrid. Each voxel in the resulting grid stores the shortest distance to the\nsurface of the mesh, with the sign indicating whether the voxel is inside or\noutside the mesh.\nPositive values represent distances outside the mesh, negative values represent\ndistances inside the mesh, and zero corresponds to the mesh surface.\nSDF grids are useful for many applications, including surface reconstruction,\ncollision detection, morphing, and volumetric modeling.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/mesh_to_sdf_grid.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "The input mesh whose volume is converted into a signed distance field grid."
      },
      {
        "name": "Voxel Size",
        "description": "The size of each voxel in object space units.\nSmaller values produce higher-resolution fields that more accurately capture\nsurface details, but require more memory and computation."
      },
      {
        "name": "Band Width",
        "description": "The width of the active voxel band around the mesh surface, measured in voxels.\nOnly voxels within this band store meaningful signed distance values.\nIncreasing this value captures a wider region around the surface at the cost\nof additional memory."
      }
    ],
    "outputs": [
      {
        "name": "SDF Grid",
        "description": "A float grid representing the signed distance field of the mesh.\nEach voxel contains the shortest signed distance to the nearest surface\npoint of the mesh, with negative values inside and positive values outside."
      }
    ]
  },
  "GeometryNodeSubdivisionSurface": {
    "label": "Subdivision Surface Node",
    "description": "The *Subdivision Surface* node adds new faces to mesh geometry using a Catmull-Clark subdivision method.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/subdivision_surface.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Level",
        "description": "The number of subdivisions to apply to the input geometry."
      },
      {
        "name": "Edge Crease",
        "description": "Controls how smooth edges should be with modifiers-generate-subsurf-creases."
      },
      {
        "name": "Vertex Crease",
        "description": "Controls how much the subdivision surface should be pulled towards the vertex.\nSimilar to edge creases, but allows individual vertices to be creased."
      },
      {
        "name": "Limit Surface",
        "description": "Places vertices at the surface that would be produced with infinite\nlevels of subdivision (smoothest possible shape)."
      },
      {
        "name": "UV Smooth",
        "description": "Controls how subdivision smoothing is applied to UVs.\nUVs are smoothed, corners on discontinuous boundary and junctions of three or more regions are kept sharp.\nUVs are smoothed, corners on discontinuous boundary,\njunctions of three or more regions and darts and concave corners are kept sharp."
      },
      {
        "name": "Boundary Smooth",
        "description": "Controls how open boundaries (and corners) are smoothed."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeDualMesh": {
    "label": "Dual Mesh Node",
    "description": "The *Dual Mesh Node* converts a mesh into its dual, i.e. faces are turned into\nvertices and vertices are turned into faces. This also means that attributes\nwhich were on the face domain are transferred to the point domain in the dual mesh.\nThe Dual Mesh node only works on manifold geometry. To work with non-manifold geometry\nit's best to remesh the geometry first.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/operations/dual_mesh.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input."
      },
      {
        "name": "Keep Boundaries",
        "description": "Keeps the non-manifold boundaries of the input mesh in place, by creating\nextra geometry, and avoiding the dual mesh transformation there."
      }
    ],
    "notes": [
      {
        "type": "warning",
        "text": "The Dual Mesh node only works on manifold geometry. To work with non-manifold geometry"
      }
    ]
  },
  "GeometryNodeMeshCube": {
    "label": "Cube Node",
    "description": "The *Cube* node generates a cuboid mesh with variable side lengths and subdivisions.\nThe inside of the mesh is still hollow like a normal cube.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/primitives/cube.rst",
    "inputs": [
      {
        "name": "Size",
        "description": "Side lengths along each of the main axes."
      },
      {
        "name": "Vertices X, Y, Z",
        "description": "Number of vertices for each side of the cube.\nThe number of vertices should be at least 1."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      },
      {
        "name": "UV Map",
        "description": "A 2D vector representing the default X/Y coordinates of the UV Map for the primitive's shape.\nThis can be connected to the /modeling/geometry_nodes/attribute/store_named_attribute,\nto be used once the Geometry Nodes Modifier get applied.\nThe UV map must be stored on the face corner in order to be accessed."
      }
    ]
  },
  "GeometryNodeMeshUVSphere": {
    "label": "UV Sphere Node",
    "description": "The *UV Sphere* node generates a spherical mesh mostly out of quads except for triangles at the top and bottom.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/primitives/uv_sphere.rst",
    "inputs": [
      {
        "name": "Segments",
        "description": "Horizontal resolution of the sphere.\nIf this is smaller than three, no mesh is generated."
      },
      {
        "name": "Rings",
        "description": "Vertical resolution of the sphere.\nIf this is smaller than two, no mesh is generated."
      },
      {
        "name": "Radius",
        "description": "Distance of vertices to the origin."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      },
      {
        "name": "UV Map",
        "description": "A 2D vector representing the default X/Y coordinates of the UV Map for the primitive's shape.\nThis can be connected to the /modeling/geometry_nodes/attribute/store_named_attribute,\nto be used once the Geometry Nodes Modifier get applied.\nThe UV map must be stored on the face corner in order to be accessed."
      }
    ]
  },
  "GeometryNodeMeshGrid": {
    "label": "Grid Node",
    "description": "The *Grid* node generates a planar mesh on the XY plane.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/primitives/grid.rst",
    "inputs": [
      {
        "name": "Size X",
        "description": "Side length of the plane in the X direction."
      },
      {
        "name": "Size Y",
        "description": "Side length of the plane in the Y direction."
      },
      {
        "name": "Vertices X",
        "description": "Number of vertices in the X direction.\nIf this is smaller than two, no mesh is generated."
      },
      {
        "name": "Vertices Y",
        "description": "Number of vertices in the Y direction.\nIf this is smaller than two, no mesh is generated."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      },
      {
        "name": "UV Map",
        "description": "A 2D vector representing the default X/Y coordinates of the UV Map for the primitive's shape.\nThis can be connected to the /modeling/geometry_nodes/attribute/store_named_attribute,\nto be used once the Geometry Nodes Modifier get applied.\nThe UV map must be stored on the face corner in order to be accessed."
      }
    ]
  },
  "GeometryNodeMeshCone": {
    "label": "Cone Node",
    "description": "Generates a cone mesh that is optionally truncated.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/primitives/cone.rst",
    "inputs": [
      {
        "name": "Vertices",
        "description": "Number of vertices in the top and/or bottom circle of the cone.\nNo geometry is generated if the number is below three."
      },
      {
        "name": "Side Segments",
        "description": "Number of vertically stacked face loops that make up the cone's sides.\nIncreasing this will add horizontal cuts.\nNo geometry is generated if the number is below one."
      },
      {
        "name": "Fill Segments",
        "description": "Number of concentric rings in the top and/or bottom.\nNo geometry is generated if the number is below one."
      },
      {
        "name": "Radius Top",
        "description": "The radius of the cone's top circle.\nIf this is zero, the circle is reduced to a single vertex."
      },
      {
        "name": "Radius Bottom",
        "description": "Same as *Radius Top* but for the bottom circle."
      },
      {
        "name": "Depth",
        "description": "Height of the generated cone."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      },
      {
        "name": "Top",
        "description": "A boolean field with a selection of the faces on the top of the cone. If the *Fill Type*\nis set to *None*, this will be a selection of the top edges instead. If *Radius Top*\nis zero, this will be a selection of the top vertex."
      },
      {
        "name": "Side",
        "description": "A boolean field with a selection of the faces on the side of the cone."
      },
      {
        "name": "Bottom",
        "description": "A boolean field with a selection of the faces on the bottom of the cone. If the *Fill Type*\nis set to *None*, this will be a selection of the bottom edges instead. If *Radius Bottom*\nis zero, this will be a selection of the bottom vertex."
      },
      {
        "name": "UV Map",
        "description": "The default UV coordinate of each face corner. This can be connected to the\n/modeling/geometry_nodes/attribute/store_named_attribute for populating a UV Map."
      }
    ],
    "properties": "Fill Type\nHow the circles at the top and bottom are filled with faces when their radius is larger than zero.",
    "notes": [
      {
        "type": "note",
        "text": "If the top and bottom radii are both zero, this node will output a single line."
      }
    ]
  },
  "GeometryNodeMeshCircle": {
    "label": "Mesh Circle Node",
    "description": "The *Mesh Circle* node generates a circular ring of edges that is optionally filled with faces.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/primitives/mesh_circle.rst",
    "inputs": [
      {
        "name": "Vertices",
        "description": "Number of vertices on the circle.\nNo geometry is generated when the number is below three."
      },
      {
        "name": "Radius",
        "description": "Distance of the vertices from the origin."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Fill Type\nHow the circle is filled with faces."
  },
  "GeometryNodeMeshLine": {
    "label": "Mesh Line Node",
    "description": "The *Mesh Line* node generates vertices in a line and connects them with edges.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/primitives/mesh_line.rst",
    "inputs": [
      {
        "name": "Count",
        "description": "Number of vertices on the line."
      },
      {
        "name": "Resolution",
        "description": "Length of individual edges.\nThe node tries to fit as many vertices as possible between the start and end point.\nThe exact end point might not be hit.\nThis is only available when the mode is set to *End Points* and the count mode is set to *Resolution*."
      },
      {
        "name": "Start Location",
        "description": "Position of the first vertex."
      },
      {
        "name": "Offset",
        "description": "Controls the direction of the line and distance between the vertices.\nThis is only available when the mode is set to *Offset*."
      },
      {
        "name": "End Location",
        "description": "Position of the last vertex.\nThis is only available when the mode is set to *End Points*."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Mode\nInputs to use to control the line.\nCount Mode\nDetermines how the number of vertices is chosen.\nThis is only available when the mode is set to *End Points*."
  },
  "GeometryNodeMeshIcoSphere": {
    "label": "Icosphere Node",
    "description": "The *Icosphere* node generates a spherical mesh that consists of equally sized triangles.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/primitives/icosphere.rst",
    "inputs": [
      {
        "name": "Radius",
        "description": "Distance of the vertices from the origin."
      },
      {
        "name": "Subdivisions",
        "description": "Number of subdivisions on top of the most basic icosphere.\nThe number of faces quadruple with every subdivision."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      },
      {
        "name": "UV Map",
        "description": "A 2D vector representing the default X/Y coordinates of the UV Map for the primitive's shape.\nThis can be connected to the /modeling/geometry_nodes/attribute/store_named_attribute,\nto be used once the Geometry Nodes Modifier get applied.\nThe UV map must be stored on the face corner in order to be accessed."
      }
    ]
  },
  "GeometryNodeMeshCylinder": {
    "label": "Cylinder Node",
    "description": "The *Cylinder* node generates a cylinder mesh.\nIt is similar to the Cone node but always uses the same radius for the circles at the top and bottom.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/primitives/cylinder.rst",
    "inputs": [
      {
        "name": "Vertices",
        "description": "Number of vertices on the circle at the top and bottom.\nNo geometry is generated if the number is below three."
      },
      {
        "name": "Side Segments",
        "description": "Number of edges running vertically along the side of the cone.\nNo geometry is generated if the number is below one."
      },
      {
        "name": "Fill Segments",
        "description": "Number of concentric rings used to fill the round faces at the top and bottom.\nNo geometry is generated if the number is below one."
      },
      {
        "name": "Radius",
        "description": "Distance of the vertices from the Z axis.\nIf this is zero, the output will be a single line."
      },
      {
        "name": "Depth",
        "description": "Height of the cylinder."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      },
      {
        "name": "Top",
        "description": "A boolean attribute field with a selection of the faces on the top of the cylinder. If the *Fill Type*\nproperty is *None*, then this will be a selection of the top edges instead. If the *Radius* is\nzero, this will be a selection of the top point."
      },
      {
        "name": "Side",
        "description": "A boolean attribute field with a selection of the faces on the side of the cylinder."
      },
      {
        "name": "Bottom",
        "description": "This is the same as the *Top* selection output, but on the bottom side of the geometry instead."
      },
      {
        "name": "UV Map",
        "description": "A 2D vector representing the default X/Y coordinates of the UV Map for the primitive's shape.\nThis can be connected to the /modeling/geometry_nodes/attribute/store_named_attribute,\nto be used once the Geometry Nodes Modifier get applied.\nThe UV map must be stored on the face corner in order to be accessed."
      }
    ],
    "properties": "Fill Type\nHow the circles at the top and bottom are filled with faces when their radius is larger than zero."
  },
  "GeometryNodeUVUnwrap": {
    "label": "UV Unwrap Node",
    "description": "The *UV Unwrap Node* generates a UV map islands based on a selection of seam edges.\nThe node implicitly performs a Pack Islands\noperation upon completion, because the results may not be generally useful otherwise.\nThe bpy.ops.uv.unwrap operator performs a similar operation in the UV editor.\nUnlike the Unwrap operator, the node doesn't perform aspect ratio correction,\nbecause it is trivial to implement with a /modeling/geometry_nodes/utilities/vector/vector_math.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/uv/uv_unwrap.rst",
    "inputs": [
      {
        "name": "Selection",
        "description": "Faces to participate in the unwrap operation.\nUVs that are part of any other face will not be affected."
      },
      {
        "name": "Seam",
        "description": "Edges to mark where the mesh is \"cut\" for the purposes of unwrapping."
      },
      {
        "name": "Margin",
        "description": "The distance to leave between UV islands."
      },
      {
        "name": "Fill Holes",
        "description": "Virtually fill holes in mesh before unwrapping, to better avoid overlaps and preserve symmetry."
      },
      {
        "name": "Method",
        "description": "This method gives a good 2D representation of a mesh.\nUses LSCM (Least Squares Conformal Mapping). This usually gives a less accurate UV\nmapping than Angle Based, but works better for simpler objects."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "In order for Blender to recognize the created attribute as a UV map,"
      }
    ]
  },
  "GeometryNodeUVTangent": {
    "label": "UV Tangent Node",
    "description": "The *UV Tangent* node generates tangent direction vectors based on a specified UV map.\nTangents are unit-length vectors that lie along the surface of the geometry\nand point in the direction of increasing *U* coordinates in the UV space.\nThey are commonly used in shading and texturing workflows, for example in\nnormal mapping or anisotropic effects.\nThis node allows for either exact or approximate tangent computation, offering\na balance between precision and performance depending on the use case.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/uv/uv_tangent.rst",
    "inputs": [
      {
        "name": "Method",
        "description": "The algorithm used to compute the tangents:\nUses the *MikkTSpace* algorithm for tangent computation.\nProduces consistent and accurate results that match the tangents used in\nBlender's shading system and exported geometry.\nThis method ensures that tangents align with the normal map space used in rendering.\nA faster approximate method that interpolates tangents across face corners with matching UVs.\nIt provides similar results at a much lower computational cost but may\nproduce less consistent results on complex or uneven surfaces.\nFor an exact tangent aligned to the surface, the cross product of the\nresult with the surface normal can be used."
      },
      {
        "name": "UV",
        "description": "The UV map used to calculate the tangent direction.\nThe UV coordinates define how the tangent vectors are oriented across the surface."
      }
    ],
    "outputs": [
      {
        "name": "Tangent",
        "description": "The tangent direction vector derived from the input UV map.\nThe output is a normalized vector field that lies along the surface and\nindicates the direction of increasing *U* values in the UV space.\nIt can be combined with normals and bitangents for constructing a complete tangent space basis."
      }
    ]
  },
  "GeometryNodeUVPackIslands": {
    "label": "Pack UV Islands Node",
    "description": "The *Pack UV Islands* node rearranges UV islands so they efficiently fill a given UV space.\nIt scales, translates, and optionally rotates islands while keeping a defined margin between them.\nThis is useful for procedurally optimizing UV layouts inside Geometry Nodes workflows,\nsuch as generating texture atlases or preparing geometry for baking.\nUnlike the UV Editor operator, this node works non-destructively and can be driven by\nprocedural inputs, making it suitable for automated or parametric UV generation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/uv/pack_uv_islands.rst",
    "inputs": [
      {
        "name": "UV",
        "description": "The UV map to pack. The topology of UV islands is determined from this input."
      },
      {
        "name": "Selection",
        "description": "Faces to consider when packing islands.\nOnly UV islands that include at least one selected face are affected.\nUVs belonging exclusively to unselected faces remain unchanged."
      },
      {
        "name": "Margin",
        "description": "The distance to leave between UV islands, expressed in UV space units."
      },
      {
        "name": "Rotate",
        "description": "Allow rotating islands to achieve a more efficient packing result."
      },
      {
        "name": "Method",
        "description": "Determines how the shape of each island is evaluated during packing.\nUses the axis-aligned bounding box of each island.\nThis is the fastest method but may be less space-efficient.\nUses the convex hull of each island.\nThis method will not place islands inside holes and provides a balance\nbetween accuracy and performance.\nUses the full island shape, including concave regions and holes.\nThis produces the tightest packing but is the slowest option."
      },
      {
        "name": "Bottom Left",
        "description": "The bottom-left corner of the region into which islands are packed."
      },
      {
        "name": "Top Right",
        "description": "The top-right corner of the region into which islands are packed."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "Unlike the UV Editor operator, this node works non-destructively and can be driven by"
      }
    ]
  },
  "GeometryNodeSampleUVSurface": {
    "label": "Sample UV Surface Node",
    "description": "The *Sample UV Surface* node finds values on a mesh's surface at specific UV locations.\nInternally the process is a \"reverse UV lookup\" from a location in 2D space. The node then\nfinds the face that corresponds to each UV coordinate, and the location within that face.\nBecause of the node's method of computation, the UV map should not have any overlapping faces.\nIf the UV map is sampled at a location with no faces or overlapping faces, the node will\noutput the default value for the data type, which is zeros for most types.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/sample/sample_uv_surface.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "A geometry containing the mesh with a UV map for sampling."
      },
      {
        "name": "Value",
        "description": "A field to evaluate on the target *Mesh* geometry for later sampling at the surface positions."
      },
      {
        "name": "UV Map",
        "description": "The mesh UV map to sample, evaluated on the *Mesh* input. Should not have overlapping faces."
      },
      {
        "name": "Sample UV",
        "description": "The coordinates to sample within the UV map."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "The data retrieved and interpolated from the *Mesh* geometry, mapped based on the node's settings and inputs."
      },
      {
        "name": "Is Valid",
        "description": "Whether the node could find a single face to sample at the UV coordinate."
      }
    ],
    "properties": "Data Type\nThe data type to use for the retrieved values.",
    "notes": [
      {
        "type": "warning",
        "text": "Because of the node's method of computation, the UV map should not have any overlapping faces."
      }
    ]
  },
  "GeometryNodeSampleNearestSurface": {
    "label": "Sample Nearest Surface Node",
    "description": "The *Sample Nearest Surface* node finds values at the closest points on\nthe surface of a source mesh geometry. Non-face attributes are interpolated\nacross the surface.\nThis node is similar to the /modeling/geometry_nodes/geometry/sample/geometry_proximity,\nbut it gives the value of any attribute at the closest surface point, not just its position.\nBecause the node samples the *surface* of a mesh rather than its edges or vertices,\nvalues from loose points and edges are ignored.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/mesh/sample/sample_nearest_surface.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "The geometry to retrieve the attribute from."
      },
      {
        "name": "Value",
        "description": "A field to evaluate on the *Source* geometry for use with the transfer method."
      },
      {
        "name": "Group ID",
        "description": "Is evaluated on the face domain and splits the input mesh into multiple parts, each with its own id."
      },
      {
        "name": "Sample Position",
        "description": "The position to start from when finding the closest location on the target mesh.\nBy default, this is the same as if the /modeling/geometry_nodes/geometry/read/position was connected."
      },
      {
        "name": "Sample Group ID",
        "description": "Determines in which group the closest nearest surface is detected."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "The data retrieved and interpolated from the *Source* geometry, mapped based on the node's settings and inputs."
      },
      {
        "name": "Is Valid",
        "description": "Whether the sampling was successful. It can fail when the sampled group is empty."
      }
    ],
    "properties": "Data Type\nThe data type to use for the retrieved values.",
    "notes": [
      {
        "type": "warning",
        "text": "Because the node samples the *surface* of a mesh rather than its edges or vertices,"
      }
    ]
  },
  "GeometryNodeStoreNamedAttribute": {
    "label": "Store Named Attribute Node",
    "description": "The *Store Named Attribute* node stores the result of a field on a geometry\nas an attribute with the specified name. If the attribute already exists, the data\ntype and domain will be updated to the values chosen in the node.\nHowever, keep in mind that the domain and data type of geometry-nodes_builtin-attributes\ncannot be changed.\nCompared with the /modeling/geometry_nodes/attribute/capture_attribute, this node basically\ndoes the same thing, but the attribute gets a name instead of an anonymous reference.\nFor reusing the data in the same node tree, the *Capture Attribute* node might be preferable\nsince it does not create the chance for name conflicts in the input geometry.\nIf the input geometry contains multiple geometry component types, the attribute will be\ncreated on each component that has the chosen domain.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/attribute/store_named_attribute.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "A boolean field input for each element indicating whether to store the attribute value for the given index.\nIf the attribute does not exist, unselected parts are filled with zero values;\notherwise, only the selected parts are filled."
      },
      {
        "name": "Value",
        "description": "The input field to evaluate."
      },
      {
        "name": "Name",
        "description": "The name to give the stored data."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Data Type\nThe data type used for the evaluated data.\nDomain\nWhich attribute domain to store the evaluated data on.",
    "notes": [
      {
        "type": "note",
        "text": "If the input geometry contains multiple geometry component types, the attribute will be"
      }
    ]
  },
  "GeometryNodeAttributeStatistic": {
    "label": "Attribute Statistic Node",
    "description": "The *Attribute Statistic* node evaluates a field on a geometry and outputs a statistic about the entire data set.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/attribute/attribute_statistic.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "A boolean field input for each element indicating whether to include its value in the statistics result\nIf the boolean is false, the corresponding value from the *Attribute* input will be ignored."
      },
      {
        "name": "Attribute",
        "description": "The attribute field to query a statistic from."
      }
    ],
    "outputs": [
      {
        "name": "Mean",
        "description": "The average value of all data."
      },
      {
        "name": "Median",
        "description": "The median value of all data."
      },
      {
        "name": "Sum",
        "description": "The sum value of all data."
      },
      {
        "name": "Min",
        "description": "The min value of all data."
      },
      {
        "name": "Max",
        "description": "The max value of all data."
      },
      {
        "name": "Range",
        "description": "The difference between the max and min value."
      },
      {
        "name": "Standard Deviation",
        "description": "How much values differ from the mean.\nA low standard deviation indicates that the values are grouped tightly together at the mean.\nA high standard deviation indicates that the values are spread out over a large range."
      },
      {
        "name": "Variance",
        "description": "The variance of all data, defined as the square of the standard deviation."
      }
    ],
    "properties": "Data Type\nThe output will be a single floating-point value.\nThe output will be a vector of three floating-point values.\nAll calculations are elementwise.\nDomain\nThe attribute domain used for the statistics\nand to evaluate the input *Attribute* field on."
  },
  "GeometryNodeCaptureAttribute": {
    "label": "Capture Attribute Node",
    "description": "The *Capture Attribute* node stores one or more fields on a geometry,\nand outputs those same fields so they can be read by other nodes.\nThis storing and retrieving of a field can also be done with the\n/modeling/geometry_nodes/attribute/store_named_attribute\nand the /modeling/geometry_nodes/geometry/read/named_attribute\nrespectively. The difference is that the *Capture Attribute* node creates\nan anonymous attribute, meaning there's no\nneed to specify a name and there's no clutter at the end.\nThis makes the node ideal for temporary data storage.\nA common use case is saving information that would normally be lost while\nconverting geometry -- see the example below.\nThe new attribute is only available in the geometry produced by this node.\nIt can't be read in the geometry of \"sibling\" or \"upstream\" nodes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/attribute/capture_attribute.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Capture Items",
        "description": "The fields to store. Inputs can be added by connecting another node's output\nto this node's blank input, or by using the *Capture Items* list in the node's\n*Properties* panel.\nThe inputs can be renamed by clicking them with Ctrl-LMB in the node\nitself or in its *Capture Items* list. The latter also accepts double clicking."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      },
      {
        "name": "Attribute",
        "description": "The node has an attribute output for each of its field inputs."
      }
    ],
    "properties": "Domain\nWhich attribute domain to store the evaluated data on.",
    "notes": [
      {
        "type": "note",
        "text": "The new attribute is only available in the geometry produced by this node."
      }
    ]
  },
  "GeometryNodeBlurAttribute": {
    "label": "Blur Attribute Node",
    "description": "The *Blur Attribute* node smooths attribute values between neighboring geometry elements.\nThe goal of each step is mixing values of each element with its neighbors.\nThe weight for element is factor for multiplying all neighbor's values before accumulating them as new primitive\nvalue.\nBlurring will only work with certain geometry types and attribute domains.\nTherefore, the attribute can only be affected on the Meshes and\nCurves components.\nThe domains this node works on is based on the field context of the node's evaluation.\nOnly domains with explicit relations with their neighbors will work with this node.\nExplicit relations for correct blurring are vertices, edges, and faces of meshes, and curve control points.\nBlurring of face corner attributes is not handled by this node,\nbecause the ideal behavior for mixing face corner values is not clear.\nAll attribute data types are supported except\nfor boolean attributes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/attribute/blur_attribute.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "The immediate value of each primitive to blur."
      },
      {
        "name": "Iterations",
        "description": "Number of repetitions of mixing value with neighbors. Each iteration is independent.\nUntil one iteration is completed, its results are not used as a source for next blurring."
      },
      {
        "name": "Weight",
        "description": "Weight of each primitive."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "Values, mixed with neighbors defined number of times."
      }
    ],
    "properties": "Data Type\nThe data type used for the evaluated data.",
    "notes": [
      {
        "type": "note",
        "text": "Blurring of face corner attributes is not handled by this node,"
      }
    ]
  },
  "GeometryNodeAttributeDomainSize": {
    "label": "Domain Size Node",
    "description": "The *Domain Size* outputs the size of an attribute domain on the selected geometry type,\nfor example, the number of edges in a mesh, or the number of points in a point cloud.\nFor more information about attribute domains, see the geometry attributes page.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/attribute/domain_size.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      }
    ],
    "outputs": [
      {
        "name": "Point Count",
        "description": "The size of the *Point* domain on any supported geometry."
      },
      {
        "name": "Edge Count",
        "description": "The size of the *Edge* domain on meshes."
      },
      {
        "name": "Face Count",
        "description": "The size of the *Face* domain on meshes."
      },
      {
        "name": "Face Corner Count",
        "description": "The size of the *Face Corner* domain on meshes."
      },
      {
        "name": "Spline Count",
        "description": "The size of the *Spline* domain on curves."
      },
      {
        "name": "Instance Count",
        "description": "The number of top-level instances in the geometry. Nested instances\nare not considered."
      }
    ],
    "properties": "Component\nWhich geometry type to retrieve the domain sizes from."
  },
  "GeometryNodeRemoveAttribute": {
    "label": "Remove Named Attribute Node",
    "description": "The *Remove Named Attribute* node deletes an attribute with a certain name from its geometry input.\nAny attribute that exists on geometry data will be automatically propagated when the geometry storing it\nis changed, which can be an expensive operation, so using this node can be a simple way to optimize\nthe performance of a geometry node tree or even to lower the memory usage of the entire scene.\nAlmost all named attributes can be removed. For certain geometry-nodes_builtin-attributes,\nremoving it will mean that a default value will be used instead. For example, removing the\ncyclic attribute on curves means that\nall curves will be non-cyclic.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/attribute/remove_named_attribute.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Pattern Mode",
        "description": "How the attributes to remove are chosen."
      },
      {
        "name": "Name",
        "description": "The name of the attribute to remove."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeGizmoDial": {
    "label": "Dial Gizmo",
    "description": "The *Dial Gizmo* node is ideal for creating gizmos that control angles.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/gizmo/dial_gizmo.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "Special gizmo value socket.\nEverything that linked into this socket will be modified when the gizmo is rotated."
      },
      {
        "name": "Position",
        "description": "Position of the gizmo in the local space of the object."
      },
      {
        "name": "Up",
        "description": "Up or normal direction of the gizmo in the viewport."
      },
      {
        "name": "Screen Space",
        "description": "If enabled, the gizmo will always have the same size in the viewport independent of the zoom level.\nThis affects the meaning of the radius input."
      },
      {
        "name": "Radius",
        "description": "In screen space mode, this is a factor on top of the default radius.\nOtherwise, this is the radius of the gizmo in Blender units."
      }
    ],
    "outputs": [
      {
        "name": "Transform",
        "description": "Should be joined into the geometry that is controlled by this gizmo."
      }
    ],
    "properties": "Color\nControls which theme color is used for this gizmo."
  },
  "GeometryNodeGizmoLinear": {
    "label": "Linear Gizmo",
    "description": "The *Linear Gizmo* node provides the most widely applicable gizmo. It can e.g. be used to control the height of\nsomething.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/gizmo/linear_gizmo.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "Special gizmo value socket.\nEverything that linked into this socket will be modified when the gizmo is moved."
      },
      {
        "name": "Position",
        "description": "Position of the gizmo in the local space of the object."
      },
      {
        "name": "Direction",
        "description": "Specifies the direction in with the gizmo points or is moved."
      }
    ],
    "outputs": [
      {
        "name": "Transform",
        "description": "Should be joined into the geometry that is controlled by this gizmo."
      }
    ],
    "properties": "Color\nControls which theme color is used for this gizmo.\nDraw Style\nAllows choosing between different styles of the gizmo."
  },
  "GeometryNodeGizmoTransform": {
    "label": "Transform Gizmo",
    "description": "The *Transform Gizmo* node provides a compound gizmo that can control a position, rotation and scale.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/gizmo/transform_gizmo.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "Special gizmo value socket.\nEverything that linked into this socket will be modified when the gizmo is modified."
      },
      {
        "name": "Position",
        "description": "Position of the gizmo in the local space of the object."
      },
      {
        "name": "Rotation",
        "description": "Local orientation of the gizmo."
      }
    ],
    "outputs": [
      {
        "name": "Transform",
        "description": "Should be joined into the geometry that is controlled by this gizmo."
      }
    ],
    "properties": "The node has properties in the sidebar which allow disabling parts of the gizmo.\nThis can be useful when e.g. controlling only a translation or only a rotation.",
    "notes": [
      {
        "type": "note",
        "text": "The rotation input is ignored by the 3D viewport if the transform orientation is set to global."
      }
    ]
  },
  "FunctionNodeInputRotation": {
    "label": "Rotation Node",
    "description": "The *Rotation* input creates a rotation from euler rotation values.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/rotation.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "properties": "X, Y, Z\nThe amount of rotation about each axes."
  },
  "GeometryNodeInputMaterial": {
    "label": "Material Node",
    "description": "The *Material* input node outputs a single material. It can be connected to other material sockets\nto make using the same material name in multiple places more convenient.\nThe Material node can also be added by dragging and dropping a material data-block into the node editor.\nThis will add the node and select the dropped material in the ui-data-block.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/material.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "properties": "- Material",
    "notes": [
      {
        "type": "tip",
        "text": "The Material node can also be added by dragging and dropping a material data-block into the node editor."
      }
    ]
  },
  "FunctionNodeInputBool": {
    "label": "Boolean Node",
    "description": "The *Boolean* node provides a Boolean value.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/boolean.rst",
    "inputs": [
      {
        "name": "This node has no input sockets.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Boolean",
        "description": "Standard Boolean output."
      }
    ],
    "properties": "Single Boolean value (true/false)."
  },
  "FunctionNodeInputInt": {
    "label": "Integer Node",
    "description": "The *Integer* node provides an integer value.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/integer.rst",
    "inputs": [
      {
        "name": "This node has no input sockets.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Integer",
        "description": "Standard integer output"
      }
    ],
    "properties": "Single integer value."
  },
  "FunctionNodeInputVector": {
    "label": "Vector Node",
    "description": "The *Vector* input node creates a single vector.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/vector.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "properties": "- X\n- Y\n- Z"
  },
  "FunctionNodeInputColor": {
    "label": "Color Node",
    "description": "The *Color* node outputs the color value chosen with the color picker widget.\nDragging colors from a color picker button into a node editor creates a Color node.\nAlpha values are preserved, if the source color has no alpha, a value of 1.0 is used.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/color.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Color",
        "description": "Color value indicated by the color picker widget."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "Dragging colors from a color picker button into a node editor creates a Color node."
      }
    ]
  },
  "FunctionNodeInputString": {
    "label": "String Node",
    "description": "The *String* input node creates a single string. It can be connected to attribute name sockets\nto make using the same attribute name in multiple places more convenient.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/string.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "properties": "- String"
  },
  "GeometryNodeInputObject": {
    "label": "Object Node",
    "description": "The *Object* input node outputs a single object. It can be connected to other object sockets\nto make using the same object in multiple places more convenient.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/object.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "properties": "- Object"
  },
  "GeometryNodeInputImage": {
    "label": "Image Node",
    "description": "Image node.\nThe *Image* node provides access to a image file which allows you to\nconveniently enter and switch images for multiple nodes in the tree.\n/modeling/geometry_nodes/input/scene/image_info",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/image.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Image",
        "description": "The image file chosen from the data-block selector."
      }
    ],
    "properties": "Image Data-Block\nThe data-block selector to select an existing image or open an image from the file browser."
  },
  "GeometryNodeInputCollection": {
    "label": "Collection Node",
    "description": "The *Collection* input node outputs a single collection. It can be connected to other collection sockets\nto make using the same collection in multiple places more convenient.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/constant/collection.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "properties": "- Collection"
  },
  "GeometryNodeSelfObject": {
    "label": "Self Object Node",
    "description": "The *Self Object* node outputs the object that contains the geometry nodes modifier\ncurrently being executed. This can be used to retrieve the original transforms.\nWhen evaluated in the Tool context, this node returns the Active object.\nThe geometry cannot be retrieved from this object with the\n/modeling/geometry_nodes/input/scene/object_info, since its final geometry is still\nbeing evaluated.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/self_object.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Self Object",
        "description": "The object currently being evaluated."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "The geometry cannot be retrieved from this object with the"
      }
    ]
  },
  "GeometryNodeIsViewport": {
    "label": "Is Viewport Node",
    "description": "The *Is Viewport* node outputs true when geometry nodes are evaluated for the viewport.\nFor the final render the node outputs false.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/is_viewport.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Is Viewport",
        "description": "Boolean value that indicates whether geometry nodes are evaluated for preview."
      }
    ]
  },
  "GeometryNodeTool3DCursor": {
    "label": "3D Cursor Node",
    "description": "The *3D Cursor* node outputs the position and orientation of the 3D cursor in the scene.\nThis node can only be used in the Tool context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/3d_cursor.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Location",
        "description": "The position of the 3D cursor."
      },
      {
        "name": "Rotation",
        "description": "The orientation of the 3D cursor as a standard rotation value."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "This node can only be used in the Tool context."
      }
    ]
  },
  "GeometryNodeCollectionInfo": {
    "label": "Collection Info Node",
    "description": "The *Collection Info* node gets information from collections.\nThis can be useful to control parameters in the geometry node tree with an external collection.\nA *Collection Info* node can be added quickly by dragging a collection into the node editor.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/collection_info.rst",
    "inputs": [
      {
        "name": "Collection",
        "description": "Collection to get the properties from."
      },
      {
        "name": "Separate Children",
        "description": "Output each child of the collection as a separate instance. The list of instances will be sorted\nalphabetically with the objects and child collections sorted together. This can be used with\nthe *Pick Instance* option in the /modeling/geometry_nodes/instances/instance_on_points to\nchoose between collection children at each point.\nBecause renaming objects and collections does not cause a modifier re-evaluation, an update will\nneed to be triggered manually for the node's output to reflect a changed name."
      },
      {
        "name": "Reset Children",
        "description": "Remove the transform of each of the collection's children when converting them to instances.\nThis is useful in order to keep child objects visually separate in the viewport,\nwhile keeping every instance located directly at the location of the point it was added for."
      }
    ],
    "outputs": [
      {
        "name": "Instances",
        "description": "Instances of the collection in world space with all modifiers applied and represented as geometry in instances."
      }
    ],
    "properties": "Transform Space\nThe transformation of the output instances. The instances are transformed, but not the geometry of the\ncollection in them.\nOutput the instances relative to the collection offset.\nJoin the input collection instances with the modified object as geometry,\nmaintaining the relative position between the objects in the scene.",
    "notes": [
      {
        "type": "tip",
        "text": "A *Collection Info* node can be added quickly by dragging a collection into the node editor."
      },
      {
        "type": "note",
        "text": "Because renaming objects and collections does not cause a modifier re-evaluation, an update will"
      }
    ]
  },
  "GeometryNodeToolMousePosition": {
    "label": "Mouse Position Node",
    "description": "The *Mouse Position* node returns information about the mouse cursor\nsuch as its position and the region's dimensions.\nWhen using this node, enable Wait for Click.\nto wait for a mouse click input (LMB) before running the operator from a menu.\nThis node can only be used in the Tool context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/mouse_position.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Mouse X",
        "description": "The region-space mouse X location, in pixels, increasing from 0 at the left."
      },
      {
        "name": "Mouse Y",
        "description": "The region-space mouse Y location, in pixels, increasing from 0 at the bottom."
      },
      {
        "name": "Region Width",
        "description": "The total X size of the region in pixels."
      },
      {
        "name": "Region Height",
        "description": "The total Y size of the region in pixels."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "When using this node, enable Wait for Click."
      },
      {
        "type": "note",
        "text": "This node can only be used in the Tool context."
      }
    ]
  },
  "GeometryNodeImageInfo": {
    "label": "Image Info Node",
    "description": "The *Image Info* node gets information from image and animation.\nThis can be useful to generate parameters in the geometry node for arbitrary images. Image information can be either\ngeneral or frame-specific.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/image_info.rst",
    "inputs": [
      {
        "name": "Image",
        "description": "Source image to get parameters from."
      },
      {
        "name": "Frame",
        "description": "Frame index for frame-specific outputs."
      }
    ],
    "outputs": [
      {
        "name": "Width",
        "description": "The number of pixels along the X axis. Specific to each frame."
      },
      {
        "name": "Height",
        "description": "The number of pixels along the Y axis. Specific to each frame."
      },
      {
        "name": "Has Alpha",
        "description": "Whether the transparency channel be different from 1 for the pixels of this image frame. Specific to each frame."
      },
      {
        "name": "Frame Count",
        "description": "The number of frames in an image or video frame sequence. For a static image, always 1."
      },
      {
        "name": "FPS",
        "description": "The number of frames per second. For static image is always 0."
      }
    ]
  },
  "GeometryNodeInputSceneTime": {
    "label": "Scene Time Node",
    "description": "The *Scene Time* node outputs the current time in the scene's animation in units of seconds or frames.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/scene_time.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Seconds",
        "description": "Current scene time in seconds."
      },
      {
        "name": "Frames",
        "description": "Current scene frame.\nAs an input in geometry nodes, this output may also output non-round numbers,\nin order to support higher quality motion blur."
      }
    ]
  },
  "GeometryNodeCameraInfo": {
    "label": "Camera Info Node",
    "description": "The *Camera Info* node outputs the information about the selected camera object.\nIt can be used to customize geometry based on the camera's parameters,\nfor example when building camera-based visual effects or aligning geometry with the camera view.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/camera_info.rst",
    "inputs": [
      {
        "name": "Camera",
        "description": "The camera object to retrieve information from.\nTo get the active camera, use the /modeling/geometry_nodes/input/scene/active_camera."
      }
    ],
    "outputs": [
      {
        "name": "Projection Matrix",
        "description": "A 4x4 matrix that represents the camera's projection transform, combining focal length,\nsensor size, shift, and clipping range. Can be used to project 3D coordinates into screen space."
      },
      {
        "name": "Focal Length",
        "description": "The focal length of the camera in millimeters. Affects field of view in perspective cameras."
      },
      {
        "name": "Sensor",
        "description": "The physical size of the camera sensor in millimeters, as a 2D vector (X and Y dimensions).\nThis value is influenced by the sensor fit properties."
      },
      {
        "name": "Shift",
        "description": "Horizontal and vertical shift of the camera view, expressed as a 2D vector."
      },
      {
        "name": "Clip Start",
        "description": "The near clipping distance of the camera."
      },
      {
        "name": "Clip End",
        "description": "The far clipping distance of the camera."
      },
      {
        "name": "Focus Distance",
        "description": "The distance from the camera to the focus point, in Blender units.\nTypically used for depth of field calculations."
      },
      {
        "name": "Is Orthographic",
        "description": "A boolean output that is *true* when the camera is in orthographic mode, and *false* when in perspective mode."
      },
      {
        "name": "Orthographic Scale",
        "description": "The orthographic scale used when the camera is set to orthographic mode.\nControls the size of the view area instead of using focal length."
      }
    ]
  },
  "GeometryNodeInputActiveCamera": {
    "label": "Active Camera Node",
    "description": "The *Active Camera* node outputs the scene's current active camera.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/active_camera.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Active Camera",
        "description": "Current active camera."
      }
    ]
  },
  "GeometryNodeObjectInfo": {
    "label": "Object Info Node",
    "description": "The *Object Info* node gets information from objects.\nThis can be useful to control parameters in the geometry node tree with an external object,\neither directly by using its geometry, or via its transformation properties.\nAn *Object Info* node can be added quickly by dragging an object into the node editor.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/object_info.rst",
    "inputs": [
      {
        "name": "Object",
        "description": "Object to get the properties from."
      },
      {
        "name": "As Instance",
        "description": "Output the entire object as single instance instead of realized geometry.\nThis allows instancing non-geometry object types, because the output will contain an instance of the object."
      }
    ],
    "outputs": [
      {
        "name": "Transform",
        "description": "Transformation Matrix containing the location, rotation and scale of the object."
      },
      {
        "name": "Location",
        "description": "Location of the object in world space."
      },
      {
        "name": "Rotation",
        "description": "Rotation of the object in world space."
      },
      {
        "name": "Scale",
        "description": "Scale of the object in world space."
      },
      {
        "name": "Geometry",
        "description": "Geometry of the object in world space with all its modifiers applied."
      }
    ],
    "properties": "Transform Space\nThe transformation of the vector and geometry outputs.\nOutput the geometry relative to the input object transform, and the location,\nrotation and scale relative to the world origin.\nBring the input object geometry, location, rotation and scale into the modified object,\nmaintaining the relative position between the two objects in the scene."
  },
  "GeometryNodeBoneInfo": {
    "label": "Bone Info Node",
    "description": "The *Bone Info* node gets bone transform properties from an armature object.\nThis can be used to control geometry node behavior with a rig or implement armature deformation using vertex group attributes.\nA dependency cycle can occur if the *Bone Info* node uses one bone and another bone in the same armature in turn\ndepends on the modified object, for example using a /animation/constraints/relationship/geometry_attribute.\nInside an armature each bone can be referenced individually, but the geometry modifier node can only add a dependency\non the entire armature. This is because the bone name is a generic string that does not generally point to a single bone.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/bone_info.rst",
    "inputs": [
      {
        "name": "Armature",
        "description": "Armature object to get bone poses from."
      },
      {
        "name": "Bone Name",
        "description": "Name of the bone to get the pose transforms from."
      }
    ],
    "outputs": [
      {
        "name": "Pose",
        "description": "Evaluated final transform of the bone."
      },
      {
        "name": "Local Pose",
        "description": "Difference between the pose and rest pose, relative to the parent bone. Not affected by the transform space."
      },
      {
        "name": "Transform Pose",
        "description": "Matrix representing the bone's location, rotation, and scale properties. Not affected by the transform space."
      },
      {
        "name": "Rest Pose",
        "description": "Original transform of the bone as defined in edit mode."
      },
      {
        "name": "Rest Length",
        "description": "Original length of the bone."
      }
    ],
    "properties": "Transform Space\nThe space in which pose transforms are defined.\nOutput the pose and rest pose relative to the armature object origin.\nBring the pose and rest pose into the modified object's space.",
    "notes": [
      {
        "type": "note",
        "text": "A dependency cycle can occur if the *Bone Info* node uses one bone and another bone in the same armature in turn"
      }
    ]
  },
  "GeometryNodeViewportTransform": {
    "label": "Viewport Transform Node",
    "description": "The *Viewport Transform* node retrieves the view direction and location of the /editors/3dview/index.\nThis node can only be used in the Tool context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/scene/viewport_transform.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Projection",
        "description": "The 3D Viewport's perspective or orthographic projection matrix."
      },
      {
        "name": "View",
        "description": "The view direction and location of the 3D viewport."
      },
      {
        "name": "Is Orthographic",
        "description": "Whether the viewport is using orthographic projection."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "This node can only be used in the Tool context."
      }
    ]
  },
  "GeometryNodeImportText": {
    "label": "Import Text Node",
    "description": "The *Import Text* node reads the contents of a plain text file and outputs it as a single string.\nThis can be useful in motion graphics or data-driven workflows where external text needs to be\nprocessed or displayed.\nCurrently, only files with the `.txt` extension are supported.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/import/txt.rst",
    "inputs": [
      {
        "name": "Path",
        "description": "The path to the txt file."
      }
    ],
    "outputs": [
      {
        "name": "String",
        "description": "The entire contents of the text file as a single string."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Currently, only files with the `.txt` extension are supported."
      }
    ]
  },
  "GeometryNodeImportOBJ": {
    "label": "Import OBJ Node",
    "description": "The *Import OBJ* node loads geometry data from a `.obj` file and outputs it as instances.\nEach object defined in the OBJ file is imported as a separate instance,\nwhich helps to preserve scene structure and optimize performance.\nThis approach allows for efficient manipulation and reuse of the geometry within Geometry Nodes workflows.\nThis node is useful for importing static 3D assets created in other modeling software.\nThe node imports only mesh geometry; materials and textures are not imported.\nOBJ Import Operator",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/import/obj.rst",
    "inputs": [
      {
        "name": "Path",
        "description": "The path to the `.obj` file to be imported."
      }
    ],
    "outputs": [
      {
        "name": "Instances",
        "description": "A collection of instances representing the objects in the imported file."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "The node imports only mesh geometry; materials and textures are not imported."
      }
    ]
  },
  "GeometryNodeImportPLY": {
    "label": "Import PLY Node",
    "description": "The *Import PLY* node imports mesh data from a `.ply` (Polygon File Format or Stanford Triangle Format) file.\nPLY files typically store geometry from 3D scanning or modeling software and can include\nvertex attributes such as colors or normals. The geometry is imported as a single mesh.\nThis node allows procedural workflows to incorporate external static geometry directly into Geometry Nodes.\nPLY Import Operator",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/import/ply.rst",
    "inputs": [
      {
        "name": "Path",
        "description": "The path to the `.ply` file to be imported."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "The mesh geometry imported from the PLY file."
      }
    ]
  },
  "GeometryNodeImportCSV": {
    "label": "Import CSV Node",
    "description": "The *Import CSV* node reads data from a CSV (Comma-Separated Values) file and generates a point cloud.\nEach row in the file becomes a point, with numeric columns imported as attributes.\nAttribute names are taken from the header row (if present), and types are inferred from the first value in each\ncolumn:\n- Integer values create integer attributes.\n- Float values create float attributes.\nOnly integer and float columns are supported. Other types, such as strings, are ignored.\nThis node is useful for visualizing external datasets in Geometry Nodes,\nsuch as for scientific visualization or procedural generation based on tabular data.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/import/csv.rst",
    "inputs": [
      {
        "name": "Path",
        "description": "The path to the CSV file. The file must be structured with one row per point and values separated by a delimiter."
      },
      {
        "name": "Delimiter",
        "description": "The character used to separate values within each row of the CSV file,\nsuch as a comma (`,`), semicolon (`;`), or tab character.\nTab characters can be inserted using the /modeling/geometry_nodes/utilities/text/special_characters."
      }
    ],
    "outputs": [
      {
        "name": "Point Cloud",
        "description": "A point cloud geometry where each row of the CSV file corresponds to a point."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Only integer and float columns are supported. Other types, such as strings, are ignored."
      },
      {
        "type": "tip",
        "text": "Tab characters can be inserted using the /modeling/geometry_nodes/utilities/text/special_characters."
      }
    ]
  },
  "GeometryNodeImportSTL": {
    "label": "Import STL Node",
    "description": "The *Import STL* node imports mesh geometry from a `.stl` (Stereolithography) file.\nSTL files are commonly used for 3D printing and CAD applications and contain only surface geometry,\ntypically as a collection of triangles with no color, texture, or other attributes.\nThis node enables incorporating external STL assets into Geometry Nodes for procedural processing or visualization.\nSTL Import Operator",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/import/stl.rst",
    "inputs": [
      {
        "name": "Path",
        "description": "The path to the `.stl` file to be imported."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "The mesh geometry imported from the STL file."
      }
    ]
  },
  "GeometryNodeImportVDB": {
    "label": "Import VDB Node",
    "description": "The *Import VDB* node loads volumetric data from a `.vdb` file\nand outputs it as a Volume geometry.\nAll grids present in the file are loaded and included in the resulting volume.\nThis node is useful for importing simulation data or procedural volumes created in external software.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/input/import/vdb.rst",
    "inputs": [
      {
        "name": "Path",
        "description": "The path to the VDB file to be imported."
      }
    ],
    "outputs": [
      {
        "name": "Volume",
        "description": "A Volume geometry containing all the grids from the specified VDB file."
      }
    ]
  },
  "GeometryNodeSetGreasePencilColor": {
    "label": "Set Grease Pencil Color Node",
    "description": "The *Set Grease Pencil Color* node sets the color and opacity attributes\nof strokes and fills on Grease Pencil geometry.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/grease_pencil/write/set_grease_pencil_color.rst",
    "inputs": [
      {
        "name": "Grease Pencil",
        "description": "The input Grease Pencil geometry."
      },
      {
        "name": "Selection",
        "description": "A boolean field to determine which elements to affect.\nElements with a value of true will be modified."
      },
      {
        "name": "Color",
        "description": "The new color to apply."
      },
      {
        "name": "Opacity",
        "description": "The opacity value to apply."
      }
    ],
    "outputs": [
      {
        "name": "Grease Pencil",
        "description": "The modified Grease Pencil geometry."
      }
    ],
    "properties": "Mode\nDetermines which component of the stroke is affected:"
  },
  "GeometryNodeSetGreasePencilDepth": {
    "label": "Set Grease Pencil Depth Node",
    "description": "The *Set Grease Pencil Depth* node sets the Grease Pencil\ndepth order to use.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/grease_pencil/write/set_grease_pencil_depth.rst",
    "inputs": [
      {
        "name": "Grease Pencil",
        "description": "The input Grease Pencil geometry."
      }
    ],
    "outputs": [
      {
        "name": "Grease Pencil",
        "description": "The modified Grease Pencil geometry."
      }
    ],
    "properties": "Depth Order\nDefines how the strokes are ordered in 3D space (for objects not displayed *In Front*).\nThe Strokes drawing order respect the order of the 2D layers list (top to bottom)\nand ignores the real position of the strokes in 3D space.\nSee 2D Layers for more information.\nThe strokes drawing order is based on the stroke location in 3D space."
  },
  "GeometryNodeSetGreasePencilSoftness": {
    "label": "Set Grease Pencil Softness Node",
    "description": "The *Set Grease Pencil Softness* node sets a stroke's softness,\nwhich controls how much a stroke's edges fade out. Higher softness values create more transparent,\nblurred edges, while lower values produce crisper, more defined strokes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/grease_pencil/write/set_grease_pencil_softness.rst",
    "inputs": [
      {
        "name": "Grease Pencil",
        "description": "Grease Pencil geometry input."
      },
      {
        "name": "Selection",
        "description": "A boolean field that controls which stroke points are affected.\nOnly elements where the selection is true will be modified.\nBy default, all strokes are affected."
      },
      {
        "name": "Softness",
        "description": "The softness value to assign. Higher values increase the fade at stroke edges.\nThis input sets the value for the ``softness`` attribute."
      }
    ],
    "outputs": [
      {
        "name": "Grease Pencil",
        "description": "The modified Grease Pencil geometry with updated softness values."
      }
    ]
  },
  "GeometryNodeInputNamedLayerSelection": {
    "label": "Named Layer Selection Node",
    "description": "The *Named Layer Selection* node outputs a Boolean field whose index value is true\nfor Grease Pencil layers whose name matches a string input.\n- The specified layer must already exist in the object.\n- If no matching layer is found, the selection will be false for all elements.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/grease_pencil/read/named_layer_selection.rst",
    "inputs": [
      {
        "name": "Name",
        "description": "The name of the Grease Pencil layer to match."
      }
    ],
    "outputs": [
      {
        "name": "Selection",
        "description": "A Boolean field for which the index for layers\nwhose name matches the input string will be true; all others are false."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "- The specified layer must already exist in the object."
      }
    ]
  },
  "GeometryNodeMergeLayers": {
    "label": "Merge Layers Node",
    "description": "Combines multiple Grease Pencil Layers into a single layer.\nMerge Layers Operator",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/grease_pencil/operations/merge_layers.rst",
    "inputs": [
      {
        "name": "Grease Pencil",
        "description": "The Grease Pencil object with multiple layers to combine."
      },
      {
        "name": "Selection",
        "description": "Operate of a subset of layers by setting the field layer index value to *true*.\nBy default, all layers are selected."
      },
      {
        "name": "Group ID",
        "description": "The index numbers of the layer to be merged.\nThis input is only visible when using *By Group ID* Mode."
      }
    ],
    "outputs": [
      {
        "name": "Grease Pencil",
        "description": "The Grease Pencil object with combined layers."
      }
    ],
    "properties": "Mode\nDetermines how to choose which layers are merged."
  },
  "GeometryNodeGreasePencilToCurves": {
    "label": "Grease Pencil to Curves Node",
    "description": "The *Grease Pencil to Curves* node converts each Grease Pencil layer into an instance\nthat contains curves.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/grease_pencil/operations/grease_pencil_to_curves.rst",
    "inputs": [
      {
        "name": "Grease Pencil",
        "description": "Standard Grease Pencil geometry."
      },
      {
        "name": "Selection",
        "description": "Selects the layers to convert."
      },
      {
        "name": "Instances as Layers",
        "description": "Create a separate curve instance for every layer.\nThis is equivalent to a Realize Instances\noperation after creating the curve geometry instances. This can simplify some logic later on, but\ntypically keeping this operation off will be much better for performance."
      }
    ],
    "outputs": [
      {
        "name": "Curves",
        "description": "Standard curves geometry."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "This is equivalent to a Realize Instances"
      }
    ]
  },
  "GeometryNodePointsToVolume": {
    "label": "Points to Volume Node",
    "description": "The *Points to Volume* node generates a fog volume sphere around every point in the input geometry.\nThe new volume grid is named \"density\".\nIt usually makes sense to combine this node with the\n/modeling/geometry_nodes/volume/operations/volume_to_mesh.\nThis node expects that point positions are not extremely large.\nFor position values of many billions, the behavior isn't guaranteed, and it may be unstable.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/points_to_volume.rst",
    "inputs": [
      {
        "name": "Points",
        "description": "Standard geometry input."
      },
      {
        "name": "Density",
        "description": "Value of voxels inside the generated fog volume."
      },
      {
        "name": "Resolution Mode",
        "description": "How the voxel size is specified.\nSpecify the approximate number of voxels along the diagonal.\nSpecify the voxel side length. It is recommended to be careful when tweaking this value,\nbecause small changes can have a large effect on the processing time."
      },
      {
        "name": "Voxel Amount Amount",
        "description": "Specify the approximate number of voxels along the diagonal."
      },
      {
        "name": "Voxel Size Size",
        "description": "Specify the voxel side length."
      },
      {
        "name": "Radius",
        "description": "Specify the radius of the sphere generated at each point."
      }
    ],
    "outputs": [
      {
        "name": "Volume",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "warning",
        "text": "This node expects that point positions are not extremely large."
      }
    ]
  },
  "GeometryNodePointsToCurves": {
    "label": "Points to Curves Node",
    "description": "The *Points to Curves* node generates a Curves geometry by taking all\npoints and inserting them to new curves. All Attributes\nfrom points are propagated to Curve Points.\nBuilt-in curves attributes stored in points will be ignored.\nTo simplify thinking about points, attributes and their positions in each curve,\nThe weight of each point in curve can be associated with a point attributes value.\nThe sorting and grouping will be reflected on the attributes as like on the Weight and Group ID.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/points_to_curves.rst",
    "inputs": [
      {
        "name": "Points",
        "description": "The Point Cloud geometry component."
      },
      {
        "name": "Curve Group ID",
        "description": "All points with the same Group ID value will be joined in the same curve.\nThe value of Group ID can be any value (negative, zero, or infinity, etc.).\nAll created curves must have at least a single point.\nThe order of curves depends both on Group ID value and on the order of Group ID values in the Point Cloud."
      },
      {
        "name": "Weight",
        "description": "If the curve contains more than one Point, the Weight of each Point is used to define the\norder of all points in curve via sorting. The goal of sorting is to have points with the minimal\nWeight value at the start of curve and the maximum Weight at the end of curve."
      }
    ],
    "outputs": [
      {
        "name": "Curves",
        "description": "The curves with all copied points from the Point Cloud,\nbut joined in curves. All other components aren't saved.\nThe resulting curves are always non-cyclic."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "To simplify thinking about points, attributes and their positions in each curve,"
      },
      {
        "type": "note",
        "text": "If points of curve have the same Weight value, the order will be the same as its original relative location."
      }
    ]
  },
  "GeometryNodeDistributePointsInVolume": {
    "label": "Distribute Points in Volume",
    "description": "The *Distribute Points in Volume* node creates points inside of volume grids.\nThe node has two basic modes of operation: distributing points randomly, or in\na regular grid. Both methods operate on all of the float grids in the volume.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/distribute_points_in_volume.rst",
    "inputs": [
      {
        "name": "Volume",
        "description": "Standard volume geometry input."
      },
      {
        "name": "Mode",
        "description": "Distribute points randomly inside of the volume. The local point count is implicitly\ndefined as a product of the global from the *Density* input and the local voxel value.\nThis method creates a distribution that is not stable as the input volume deforms.\nDistribute the points in a grid pattern inside of the volume. At each grid point, the voxel\nvalue is used to determine whether to add a point."
      },
      {
        "name": "Density Random",
        "description": "Number of points to sample per unit volume."
      },
      {
        "name": "Seed Random",
        "description": "Seed used by the random number generator to generate random points"
      },
      {
        "name": "Spacing Grid",
        "description": "Spacing between grid points."
      },
      {
        "name": "Threshold Grid",
        "description": "Minimum value of a volume cell to contain a grid point."
      }
    ],
    "outputs": [
      {
        "name": "Points",
        "description": "Standard point cloud geometry output."
      }
    ]
  },
  "GeometryNodeDistributePointsOnFaces": {
    "label": "Distribute Points on Faces",
    "description": "The *Distribute Points on Faces* node places points on the surface of the input geometry object.\nPoint, corner, and polygon attributes of the input geometry are transferred to the generated points.\nThat includes vertex weights and UV maps.\nAdditionally, the node has *Normal* and *Rotation* outputs.\nThe node also generates a stable ID, stored in the built-in ``id`` attribute, used as\na stable identifier for each point. When the mesh is deformed or the density changes\nthe values will be consistent for each remaining point. This attribute is used in\nthe Random Value and\nInstance on Points nodes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/distribute_points_on_faces.rst",
    "inputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry input.\nThe input geometry must contain a mesh with faces."
      },
      {
        "name": "Selection",
        "description": "The selection of which face corners should be considered for point distribution."
      },
      {
        "name": "Distance Min",
        "description": "The minimal distance points can have to each other.\nThis option is only available for the *Poisson Disk* distribution method.\nAt its default value of zero, the node's behavior is the same as it is in *Random* mode,\nbecause none of the internally generated points are removed."
      },
      {
        "name": "Density Max",
        "description": "The point density for the point distribution. The unit is in number of points per square meter.\nThis value is multiplied by the values from the *Density* input. Only available in *Poisson Disk* mode.\nThis will be capped on distributions by the *Distance Min* option.\nIf the density is greater than what the minimal distance allows,\nno new points will be added after this threshold has been passed."
      },
      {
        "name": "Density",
        "description": "The number of points to distribute per square meter on each mesh face.\nThis value is multiplied by the values from the *Density Attribute*.\nIn *Poisson Disk* mode, this value is multiplied by the *Density Max* input for the final density."
      },
      {
        "name": "Seed",
        "description": "The random Seed to use when generating points."
      }
    ],
    "outputs": [
      {
        "name": "Points",
        "description": "Generated points. Named attributes are copied to the result mesh, along with the data in the other\nattribute field outputs."
      },
      {
        "name": "Normal",
        "description": "The Normal of the triangle on which each point is scattered."
      },
      {
        "name": "Rotation",
        "description": "An XYZ Euler rotation built from the normal attribute for convenience. Such a value can also be\nbuilt from the normal with the /modeling/geometry_nodes/utilities/rotation/euler_to_rotation.\nKeep in mind that the Z axis of the result rotation will be arbitrary, since the mesh normal used\nto create the rotation does not have enough information to set all three rotation axes."
      }
    ],
    "properties": "Distribution Method\nDistribute points randomly on the surface. This is the fastest distribution method.\nDistribute points randomly on the surface while taking a minimum distance into account.\nLegacy Normal\nBy default, the node uses smooth and custom normals for the *Normal* and *Rotation* values .\nAn earlier version of this node only uses \"true\" normals,\nthis option brings back this behavior of only using \"true\" normals.\nThis option can only be available in the Sidebar.",
    "notes": [
      {
        "type": "note",
        "text": "The input geometry must contain a mesh with faces."
      },
      {
        "type": "note",
        "text": "This will be capped on distributions by the *Distance Min* option."
      }
    ]
  },
  "GeometryNodePoints": {
    "label": "Points Node",
    "description": "The *Points* node generate a point cloud with positions and radii defined by\nfields.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/points.rst",
    "inputs": [
      {
        "name": "Count",
        "description": "The number of points to create."
      },
      {
        "name": "Position",
        "description": "The position of each generated point."
      },
      {
        "name": "Radius",
        "description": "The radius of each point."
      }
    ],
    "outputs": [
      {
        "name": "Points",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Since the point cloud is created from scratch, the *Position* and *Radius* inputs can only depend on"
      }
    ]
  },
  "GeometryNodeSetPointRadius": {
    "label": "Set Point Radius Node",
    "description": "The *Set Point Radius* node controls the size each selected point cloud point should display with in the viewport.\nThe input node for this data is the /modeling/geometry_nodes/geometry/read/radius.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/set_point_radius.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Radius",
        "description": "Float value indicating the radius of the point geometry at each point."
      },
      {
        "name": "Selection",
        "description": "Boolean input for selecting which points will have the radius value applied."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeDistributePointsInGrid": {
    "label": "Distribute Points in Grid",
    "description": "The *Distribute Points in Grid* node generates points within the active region\nof a voxel grid. The number and placement of points can be controlled using\nthe grid's density values and various distribution parameters.\nThis node is useful for scattering geometry procedurally inside a volumetric\nregion, such as distributing particles in a fog volume, populating points in\na simulation domain, or sampling areas defined by a signed distance field (SDF)\nor density grid.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/distribute_points_in_grid.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input grid that defines the volume within which points are distributed.\nThe grid's values determine where points can be placed\u2014typically based on\ndensity or occupancy."
      },
      {
        "name": "Density Random",
        "description": "A scaling factor applied to the voxel values that determines the expected\nnumber of points to generate per unit volume.\nHigher values produce denser distributions of points."
      },
      {
        "name": "Seed Random",
        "description": "The seed value used by the random number generator for reproducible results.\nChanging this value alters the random point distribution without affecting\nother parameters."
      },
      {
        "name": "Spacing Grid",
        "description": "The distance between points when using the *Grid* distribution method.\nControls how tightly points are packed inside the volume."
      },
      {
        "name": "Threshold Grid",
        "description": "The minimum voxel density value required for a point to be generated.\nVoxels below this threshold are ignored, which can be used to restrict\npoint placement to denser or more meaningful regions."
      }
    ],
    "outputs": [
      {
        "name": "Points",
        "description": "A set of generated points positioned inside the grid's active volume,\ndistributed according to the chosen *Distribution Method* and input parameters."
      }
    ],
    "properties": "Distribution Method\nThe method used to scatter points inside the grid volume:\nDistribute points randomly inside the grid, weighted by voxel density.\nProduces a natural, stochastic scattering pattern.\nDistribute points evenly in a regular grid pattern inside the volume.\nThe spacing between points is controlled by the *Spacing* input."
  },
  "GeometryNodePointsToSDFGrid": {
    "label": "Points to SDF Grid",
    "description": "The *Points to SDF Grid* node generates a Signed Distance Field (SDF)*grid\nfrom a set of input points. Each voxel in the resulting grid stores the\nshortest signed distance to the nearest point, allowing points to be\nrepresented as smooth, volumetric shapes.\nPositive values represent distances outside the influence of the points,\nnegative values represent distances inside, and zero corresponds to the surface\nof the generated implicit sphere around each point.\nThis node is useful for constructing volumetric fields or collision volumes\nfrom particles, instances, or procedurally generated point clouds.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/points_to_sdf_grid.rst",
    "inputs": [
      {
        "name": "Points",
        "description": "The input points that define the centers of the generated SDF regions."
      },
      {
        "name": "Radius",
        "description": "The radius of influence for each point, defining how far the signed\ndistance extends from the point center. Each point is treated as a sphere\nwith this radius."
      },
      {
        "name": "Voxel Size",
        "description": "The size of each voxel in object space units.\nSmaller voxel sizes yield higher-resolution fields that better capture\nfine detail, at the cost of increased memory and processing time."
      }
    ],
    "outputs": [
      {
        "name": "SDF Grid",
        "description": "A scalar (float) grid representing the signed distance field of the input points.\nEach voxel stores the shortest signed distance to any point's surface,\nwith negative values inside the combined spheres and positive values outside."
      }
    ]
  },
  "GeometryNodePointsToVertices": {
    "label": "Points to Vertices Node",
    "description": "The *Points to Vertices* node generate a mesh vertex in the output geometry for\neach point cloud point in the input geometry.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/point/points_to_vertices.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field used to determine if each point will be converted to a vertex."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ]
  },
  "ShaderNodeRGBCurve": {
    "label": "ShaderNodeRGBCurve",
    "description": "",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/color/rgb_curves.rst"
  },
  "FunctionNodeSeparateColor": {
    "label": "Separate Color Node",
    "description": "Splits an image into its channels,\nbased on a particular Color Model.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/color/separate_color.rst",
    "inputs": [
      {
        "name": "Color",
        "description": "Standard color input."
      }
    ],
    "outputs": [
      {
        "name": "The outputs of this node depend on the Mode property (see above).",
        "description": ""
      },
      {
        "name": "Alpha",
        "description": "The opacity value."
      }
    ],
    "properties": "Mode\nThe color model to output."
  },
  "FunctionNodeCombineColor": {
    "label": "Combine Color Node",
    "description": "Combines four grayscale channels into one color image,\nbased on a particular Color Model.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/color/combine_color.rst",
    "inputs": [
      {
        "name": "The inputs of this node depend on the Mode property (see below).",
        "description": ""
      },
      {
        "name": "Alpha",
        "description": "The opacity of the output color."
      }
    ],
    "properties": "Mode\nThe color model to use."
  },
  "GeometryNodeWarning": {
    "label": "Warning Node",
    "description": "Outputs a custom message that is displayed in the\nmodifiers-geometry-nodes-warnings panel of the Geometry Nodes modifier.\nThis allows node groups to communicate expectations, assumptions, or error conditions\nabout input values, such as required ranges, missing data, or unsupported configurations.\nBy default, warnings are propagated through all parent node groups.\nThis behavior can be controlled using the\nbpy.types.Node.warning_propagation setting on each node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/output/warning.rst",
    "inputs": [
      {
        "name": "Show",
        "description": "Controls whether the warning is shown in the\nmodifiers-geometry-nodes-warnings panel.\nWhen disabled, the warning is suppressed."
      },
      {
        "name": "Message",
        "description": "The text message to display.\nThis can be used to describe incorrect inputs, required conditions,\nor other relevant information for users of the node group."
      }
    ],
    "outputs": [
      {
        "name": "Show",
        "description": "Passthrough of the *Show* input, allowing the warning state to be forwarded\nto other nodes."
      }
    ],
    "properties": "Warning Type\nThe severity of the message, which also affects the icon shown in the warnings panel.\nInformational message that does not indicate a problem.\nIndicates a potential issue that may produce unexpected results.\nIndicates an invalid configuration that is likely to produce incorrect results."
  },
  "GeometryNodeViewer": {
    "label": "Viewer Node",
    "description": "The *Viewer* node allows viewing data from inside a geometry node group in both the\nSpreadsheet Editor and the 3D Viewport.\nAny geometry or attribute connected to the viewer can be visualized in the viewport,\nand its evaluated attribute values can be inspected in the spreadsheet.\nOther data can also be viewed and inspected such as scaler values and grids by showing them in the spreadsheet.\nThe *Viewer* node cannot be used in the Tool context\u2014only in the *Modifier* context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/output/viewer.rst",
    "inputs": [
      {
        "name": "Inputs can be added by dragging a socket into the blank socket",
        "description": ""
      },
      {
        "name": "or from the bpy.types.NodeGeometryViewerItem properties.",
        "description": ""
      }
    ],
    "properties": "Domain\nThe attribute domain used to evaluate the *Value* input.\nThe *Auto* option chooses the domain automatically based on the connected nodes.",
    "notes": [
      {
        "type": "note",
        "text": "The *Viewer* node cannot be used in the Tool context\u2014only in the *Modifier* context."
      },
      {
        "type": "note",
        "text": "Only number keys (1\u20139) are supported."
      },
      {
        "type": "note",
        "text": "Complex data types such as geometry or grids cannot be previewed this way and must be visualized"
      }
    ]
  },
  "GeometryNodeSetSplineCyclic": {
    "label": "Set Spline Cyclic Node",
    "description": "The *Set Spline Cyclic* node changes whether splines loop back on themselves --\nthat is, whether their first and last control points are connected.\nYou can use the /modeling/geometry_nodes/curve/read/is_spline_cyclic\nto read this property.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/write/set_spline_cyclic.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Whether to change the cyclic setting for each spline. *True* means the\nsetting will be changed, *false* means it will stay the same."
      },
      {
        "name": "Cyclic",
        "description": "Whether to connect the first and last control points of each spline."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeCurveSetHandles": {
    "label": "Set Handle Type Node",
    "description": "Sets the handle type for the points on the B\u00e9zier curve that are in the selection.\nA selection for a certain handle type can be retrieved with\nthe /modeling/geometry_nodes/curve/read/handle_type_selection.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/write/set_handle_type.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "B\u00e9zier curve."
      },
      {
        "name": "Selection",
        "description": "The points whose handle types will be changed."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard curve output."
      }
    ],
    "properties": "Mode\nWhether to update left or right or both handles.\nWhen both are selected, both the left and the right handles will be updated.\nUpdate the left handles.\nUpdate the right handles.\nHandle Type\nThe handle type to switch to. See the B\u00e9zier curves\npage for more details on the different handle types."
  },
  "GeometryNodeSetCurveNormal": {
    "label": "Set Curve Normal Node",
    "description": "The *Set Curve Normal* controls the method used to calculate curve normals for every curve.\nThe node doesn't set the normals directly, those are calculated later as necessary.\nCombined with the tilt attribute value\nat each control point, this will define the final normals accessible with the\n/modeling/geometry_nodes/geometry/read/normal.\nInternally this node adjusts the values of the ``normal_mode`` attribute on each curve.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/write/set_curve_normal.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input, containing curves."
      },
      {
        "name": "Selection",
        "description": "Whether or not to change the value on each curve."
      },
      {
        "name": "Mode",
        "description": "The method for evaluation of the curve's normals\nThe final normals are calculated to have the smallest twist around\nthe curve tangent across the whole curve.\nThe final normals are calculated so that they are perpendicular to the Z axis and the tangent.\nIf a series of points is vertical, the X axis is used.\nUse the stored custom normal attribute (``custom_normal``) as the final normals.\nThis mode adds a *Normal* input that can be used to set the value of the custom normal.\nCustom normals are not rotation invariant,\nmeaning normals must be set after any rotation transformations;\ni.e. at the end of the node tree or at the bottom of the modifier stack."
      },
      {
        "name": "Normal Free",
        "description": "Input for the custom normal attribute (``custom_normal``) when using *Free* mode."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Custom normals are not rotation invariant,"
      }
    ]
  },
  "GeometryNodeSetCurveTilt": {
    "label": "Set Curve Tilt Node",
    "description": "The *Set Curve Tilt* controls the tilt angle at each curve control point.\nThat angle rotates normal vector which is generated at each point\nwhen evaluating the curve. The normal then can be retrieved with\nthe /modeling/geometry_nodes/geometry/read/normal.\nThe rotation of the normal vector is an Axis Angle rotation.\nIt is the same as the /modeling/geometry_nodes/utilities/vector/vector_rotate operation\nwith the tangent vector as the axis, the raw evaluated normal is used as\nthe original vector, and the tilt as the rotation angle.\nThe input node for this data is the /modeling/geometry_nodes/curve/read/curve_tilt.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/write/set_curve_tilt.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input, containing curves."
      },
      {
        "name": "Selection",
        "description": "Whether or not to change the value on each control point. True values mean the value will be changed,\nfalse values mean the value will remain the same."
      },
      {
        "name": "Tilt",
        "description": "The tilt angle for each control point."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeSetCurveRadius": {
    "label": "Set Curve Radius Node",
    "description": "The *Set Curve Radius* controls the radius of the curve, used for operations like the size of the profile\nin the Curve to Mesh node. The value is set for\nevery control point, and is then interpolated to each evaluated point in between the control points.\nThe input node for this data is the Radius node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/write/set_curve_radius.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input, containing curves."
      },
      {
        "name": "Selection",
        "description": "Whether or not to change the value on each control point. True values mean the value will be changed,\nfalse values mean the value will remain the same."
      },
      {
        "name": "Radius",
        "description": "The radius value for each control point."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeSetSplineResolution": {
    "label": "Set Spline Resolution Node",
    "description": "The *Set Spline Resolution* node sets the value for how many evaluated points should be generated on the curve for\nevery control point. It only has an effect on NURBS, B\u00e9zier, and Catmull Rom splines. In case of\nB\u00e9zier splines, the resolution does not have an effect on segments between vector handles.\nThe evaluated points are displayed in the viewport, used in the\n/modeling/geometry_nodes/curve/operations/curve_to_mesh node,\nand optionally used in the /modeling/geometry_nodes/curve/operations/resample_curve.\nThe input node for this data is the /modeling/geometry_nodes/curve/read/spline_resolution.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/write/set_spline_resolution.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Whether or not to change the resolution value on each spline. True values mean the value will be changed,\nfalse values mean the resolution will remain the same."
      },
      {
        "name": "Resolution",
        "description": "The number of evaluated points generated for each control point in NURBS and B\u00e9zier splines.\nIt controls the accuracy of operations like trimming or sampling a curve.\nHigher resolutions are more accurate, but slower."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeSetCurveHandlePositions": {
    "label": "Set Handle Positions Node",
    "description": "The *Set Handle Positions* node sets the positions for the handles of B\u00e9zier curves.\nThey can be used to alter the generated shape of the curve.\nThe input node for this data is the /modeling/geometry_nodes/curve/read/curve_handle_positions.\nSee the B\u00e9zier curves page for more details.\nWhen the position is changed, *Auto* handle types will be converted to *Aligned*, and *Vector* handle\ntypes will be converted to *Free*.\nThe left and right handles cannot be changed at the same time with this node. That is because it would\nbreak the alignment for left and right handles at the same control point.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/write/set_handle_positions.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input, containing curves."
      },
      {
        "name": "Selection",
        "description": "Whether or not to change the handle position on each control point.\nTrue values mean the resolution will be changed, false values mean\nthe resolution will remain the same."
      },
      {
        "name": "Position",
        "description": "The new handle position."
      },
      {
        "name": "Offset",
        "description": "An optional translation for each handle. This is evaluated at the same time as the *Position* input,\nmeaning that fields evaluated for it will not reflect the changed position."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Left / Right\nWhether to set the handle position of the left or right handle.\nThe *Left* handle is closer to the start of the spline, and the *Right* handle is closer to the end.",
    "notes": [
      {
        "type": "note",
        "text": "When the position is changed, *Auto* handle types will be converted to *Aligned*, and *Vector* handle"
      },
      {
        "type": "note",
        "text": "The left and right handles cannot be changed at the same time with this node. That is because it would"
      },
      {
        "type": "note",
        "text": "The handle positions are the global position of the handle, they are not relative to"
      }
    ]
  },
  "GeometryNodeCurveSplineType": {
    "label": "Set Spline Type Node",
    "description": "Sets the spline type for the splines in the curve component that\nare in the selection.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/write/set_spline_type.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input with a curve component."
      },
      {
        "name": "Selection",
        "description": "The splines whose spline types will be changed."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard curve output."
      }
    ],
    "properties": "Spline Type\nThe type to convert the splines in the selection to.\nRead the Spline Types page for more details\non the different spline types.\nConvert to a B\u00e9zier spline. A spline converted from a poly spline gets vector handles,\nwhile one converted from NURBS or Catmull Rom spline gets auto handles.\nWhen converting from a NURBS spline to a B\u00e9zier spline,\nat least six points are needed.\nWhen the number of points is not a multiple of three\na full conversion is not possible and the spline has to be truncated.\nConvert to a NURBS spline.\nConvert to a poly spline.\nConvert to a Catmull Rom spline.",
    "notes": [
      {
        "type": "note",
        "text": "When converting from a NURBS spline to a B\u00e9zier spline,"
      }
    ]
  },
  "GeometryNodeOffsetPointInCurve": {
    "label": "Offset Point in Curve Node",
    "description": "The *Offset Point in Curve* node retrieves other points in the same curve as\nthe input control point. This is like starting at a specific control point and\nwalking along neighboring points toward the start or end of the curve.\nConceptually the operation is similar to the\n/modeling/geometry_nodes/mesh/topology/offset_corner_in_face,\nbut the point index doesn't wrap around to the other end of the curve unless it is cyclic.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/topology/offset_point_in_curve.rst",
    "inputs": [
      {
        "name": "Point Index",
        "description": "The index of the input control point.\nBy default this uses the index\nfrom the field context, which makes it important that the node is evaluated on\nthe point domain."
      },
      {
        "name": "Offset",
        "description": "The number of points to move around the curve before finding the result.\nIf the curve is cyclic\nand the offset goes past the start or end point of the curve, it will wrap around\nto the other side."
      }
    ],
    "outputs": [
      {
        "name": "Is Valid Offset",
        "description": "Whether the input control point plus the offset is a valid index of the original curve.\nAny offset in a cyclic curve is always valid."
      },
      {
        "name": "Point Index",
        "description": "The index of the offset curve point."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "By default this uses the index"
      }
    ]
  },
  "GeometryNodePointsOfCurve": {
    "label": "Points of Curve Node",
    "description": "The *Points of Curve* node retrieves indices of specific control points in a curve.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/topology/points_of_curve.rst",
    "inputs": [
      {
        "name": "Curve Index",
        "description": "The index of the input curve.\nBy default this uses the index\nfrom the field context, which makes it important that the node is evaluated on\nthe curve domain."
      },
      {
        "name": "Weights",
        "description": "Values used to sort the curve's control points.\nBy default the control points are sorted by index, so the control points with the smallest indices come first."
      },
      {
        "name": "Sort Index",
        "description": "Which of the sorted control points to use for the *Point Index* output. If the value is larger than\nthe total number of control points, it will wrap around to the beginning."
      }
    ],
    "outputs": [
      {
        "name": "Point Index",
        "description": "The index of one of the curve's control points, chosen by the *Sort Index* input."
      },
      {
        "name": "Total",
        "description": "The number of control points in the curve."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "By default this uses the index"
      }
    ]
  },
  "GeometryNodeCurveOfPoint": {
    "label": "Curve of Point Node",
    "description": "The *Curve of Point* node retrieves the index of the curve a control point is part of.\nThis node is conceptually similar to the /modeling/geometry_nodes/mesh/topology/face_of_corner.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/topology/curve_of_point.rst",
    "inputs": [
      {
        "name": "Point Index",
        "description": "The index of the input control point.\nBy default this uses the index\nfrom the field context, which makes it important that the node is evaluated on\nthe point domain."
      }
    ],
    "outputs": [
      {
        "name": "Curve Index",
        "description": "The index of the curve the control point is part of."
      },
      {
        "name": "Index in Curve",
        "description": "How far along the control point is along its curve, with a value of 0 for the first point in each curve."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "By default this uses the index"
      }
    ]
  },
  "GeometryNodeInputCurveHandlePositions": {
    "label": "Curve Handle Positions Node",
    "description": "Gets the two handle positions of each control point in a B\u00e9zier spline.\nYou can use the /modeling/geometry_nodes/curve/write/set_handle_positions\nto change these positions.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/curve_handle_positions.rst",
    "inputs": [
      {
        "name": "Relative",
        "description": "Output the handle positions relative to the control point\ninstead of in the local space of the geometry."
      }
    ],
    "outputs": [
      {
        "name": "Left",
        "description": "The position of the control point's left handle."
      },
      {
        "name": "Right",
        "description": "The position of the control point's right handle."
      }
    ]
  },
  "GeometryNodeInputSplineCyclic": {
    "label": "Is Spline Cyclic Node",
    "description": "The *Is Spline Cyclic* controls whether each of the curve splines start and endpoints form a connection.\nIts output corresponds to the built-in ``cyclic`` attribute on the curve spline domain.\nThe node to set this data is the /modeling/geometry_nodes/curve/write/set_spline_cyclic.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/is_spline_cyclic.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Cyclic",
        "description": "Whether the spline is cyclic."
      }
    ]
  },
  "GeometryNodeCurveEndpointSelection": {
    "label": "Endpoint Selection Node",
    "description": "The *Endpoint Selection* node provides a selection for an arbitrary number of endpoints in each spline in a curve.\nThe selection operates for every control point. This may not correspond to the evaluated\npoints displayed in the viewport for NURBS and B\u00e9zier splines, where one control point may\ncorrespond to many evaluated points.\nTo use this data after the curve has been converted to another data type like mesh or a point cloud,\nthe /modeling/geometry_nodes/attribute/capture_attribute can be used.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/endpoint_selection.rst",
    "inputs": [
      {
        "name": "Start Size",
        "description": "The number of points to select from the start."
      },
      {
        "name": "End Size",
        "description": "The number of points to select from the end."
      }
    ],
    "outputs": [
      {
        "name": "Selection",
        "description": "Selection of the start and end of each spline of the curve."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "The selection operates for every control point. This may not correspond to the evaluated"
      },
      {
        "type": "tip",
        "text": "To use this data after the curve has been converted to another data type like mesh or a point cloud,"
      }
    ]
  },
  "GeometryNodeInputSplineResolution": {
    "label": "Spline Resolution Node",
    "description": "The *Spline Resolution* outputs the number of evaluated curve points that will be generated for\nevery control point on the spline. This node works for NURBS, B\u00e9zier, and Catmull Rom splines.\nFor poly splines, there is a one-to-one correspondence between original points and evaluated points,\nso the resolution does not have an effect.\nOn B\u00e9zier splines, the resolution does not have an effect on segments between vector handles,\nsince there are no extra evaluated points between the neighboring control points.\nThe node to set this data is the /modeling/geometry_nodes/curve/write/set_spline_resolution.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/spline_resolution.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Resolution",
        "description": "The integer resolution value for each spline."
      }
    ]
  },
  "GeometryNodeSplineLength": {
    "label": "Spline Length Node",
    "description": "The *Spline Length* node outputs the total length of each spline, as a distance, or a number of points.\nThis is different than the Curve Length node,\nwhich adds up the total length for all of the curve's splines.\nThe output values correspond to the spline domain, but the node can be used to output a value for every\ncurve control point as well.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/spline_length.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Length",
        "description": "The length of each spline."
      },
      {
        "name": "Point Count",
        "description": "The number of control points in each spline."
      }
    ]
  },
  "GeometryNodeInputCurveTilt": {
    "label": "Curve Tilt Node",
    "description": "The *Curve Tilt* node outputs the angle used to turn the curve normal\naround the direction of the curve tangent in its evaluated points.\nKeep in mind that the output is per control point, just like the values\nthat can be controlled in curve Edit Mode. For NURBS and B\u00e9zier splines,\nthe values will be interpolated to the final evaluated points.\nThe input node for this data is the Set Curve Tilt node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/curve_tilt.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Tilt",
        "description": "The tilt angle for the normal in radians."
      }
    ]
  },
  "GeometryNodeInputTangent": {
    "label": "Curve Tangent Node",
    "description": "The *Curve Tangent* node outputs the direction that a curve points in at each control point,\ndepending on the direction of the curve (which can be controlled with\nthe /modeling/geometry_nodes/curve/operations/reverse_curve). The output values are normalized vectors.\nFor NURBS and B\u00e9zier spline curves, keep in mind that the value retrieved from this node is\nthe value at every control point, which may not correspond to the visible *evaluated* points.\nFor example, a B\u00e9zier spline might have 48 evaluated points, but only four control points,\nif its resolution is 12. For NURBS splines the difference may be even more pronounced and the result\nmay not be as expected. A /modeling/geometry_nodes/curve/operations/resample_curve can be used to\ncreate a poly spline, where there is a control point for every evaluated point.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/curve_tangent.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Tangent",
        "description": "The direction of the curve at every control point."
      }
    ],
    "notes": [
      {
        "type": "warning",
        "text": "For NURBS and B\u00e9zier spline curves, keep in mind that the value retrieved from this node is"
      }
    ]
  },
  "GeometryNodeSplineParameter": {
    "label": "Spline Parameter Node",
    "description": "The *Spline Parameter* node outputs how far along each spline a control point is.\nThe *Factor* output is different from dividing the index by the total number of control points,\nbecause the control points might not be equally spaced along the curve.\nThe first value is zero, so the output corresponds to the length at the control point rather than\nincluding the length of the following segment.\nWhen used on the spline domain, the node outputs the portion of the total length of the curve (including\nall splines) has been traversed at the start of each spline. The order of the curve's splines is visible\nin the Spreadsheet Editor.\nFor NURBS and B\u00e9zier spline curves, keep in mind that the value retrieved from this node is\nthe value at every control point, which may not correspond to the visible *evaluated* points.\nFor NURBS splines the difference may be even more pronounced and the result may not be as expected.\nA /modeling/geometry_nodes/curve/operations/resample_curve node can be used to create a poly spline,\nwhere there is a control point for every evaluated point.\nWhen the *Length* is zero, the *Factor* is arbitrary. In this case the result is\nexceptionally calculated dividing the index by the total number of control points or curves.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/spline_parameter.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Factor",
        "description": "When the node is used on the point domain, the value is the portion of the spline's\ntotal length at each control point. On the spline domain it is the portion of the\ncurve's total length at the start of the spline."
      },
      {
        "name": "Length",
        "description": "When the node is used on the point domain, the value is the distance along the spline to each\ncontrol point. On the spline domain it is the length along the entire curve at the start\nof the spline."
      },
      {
        "name": "Index",
        "description": "Each control point's index on its spline. This is different from the output of the\nindex node, which also counts the\ncontrol points in all previous splines."
      }
    ],
    "notes": [
      {
        "type": "warning",
        "text": "For NURBS and B\u00e9zier spline curves, keep in mind that the value retrieved from this node is"
      },
      {
        "type": "note",
        "text": "When the *Length* is zero, the *Factor* is arbitrary. In this case the result is"
      }
    ]
  },
  "GeometryNodeCurveLength": {
    "label": "Curve Length Node",
    "description": "The *Curve Length* node outputs the length of all splines added together.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/curve_length.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input."
      }
    ]
  },
  "GeometryNodeCurveHandleTypeSelection": {
    "label": "Handle Type Selection Node",
    "description": "Creates a selection based on the handle types of the control points.\nThe handle type of each control point can be changed with the\n/modeling/geometry_nodes/curve/write/set_handle_type.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/read/handle_type_selection.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Selection",
        "description": "Boolean field set to true wherever the handle type matches."
      }
    ],
    "properties": "Mode\nWhether to consider left and/or right handles.\nWhen both are selected, the output value is true\nif either of the handles are of the chosen type.\nConsider the left handle.\nConsider the right handle.\nHandle Type\nHandle type for which the selection will be true.\nSee the B\u00e9zier curves page for more details\non the different handle types."
  },
  "GeometryNodeResampleCurve": {
    "label": "Resample Curve Node",
    "description": "The Resample Curve node creates a poly spline for each input spline.\nIn the *Count* and *Length* modes, the control points of the new poly\nsplines will have uniform spacing.\nUse a field as an input to have a different count/length for each spline.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/resample_curve.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Whether or not to resample each spline. True values mean spline will be resampled to a poly spline,\nfalse values mean the spline will be unaffected."
      },
      {
        "name": "Mode",
        "description": "How to specify the amount of samples.\nSample the specified number of points along each spline.\nCalculate the number of samples by splitting each spline into segments with the specified length.\nThe length will be rounded down so that a whole number of samples will fit in each input spline.\nEvaluate the spline's points based on the resolution attribute for NURBS and B\u00e9zier splines.\nChanges nothing for poly splines."
      },
      {
        "name": "Count Count",
        "description": "The number of control points on the new splines."
      },
      {
        "name": "Length Length",
        "description": "The approximate length between the control points of the new splines.\nA /modeling/geometry_nodes/curve/operations/trim_curve can be used with\na multiple of the input length to make the distance between each sampled point exact,\neven when the length of the spline changes."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "Use a field as an input to have a different count/length for each spline."
      },
      {
        "type": "tip",
        "text": "A /modeling/geometry_nodes/curve/operations/trim_curve can be used with"
      }
    ]
  },
  "GeometryNodeCurvesToGreasePencil": {
    "label": "Curves to Grease Pencil Node",
    "description": "The *Curves to Grease Pencil* node Converts top-level curve instances into Grease Pencil layers",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/curves_to_grease_pencil.rst",
    "inputs": [
      {
        "name": "Curves",
        "description": "Either plain curves or curve instances."
      },
      {
        "name": "Selection",
        "description": "Either a curve or instance selection."
      },
      {
        "name": "Instances as Layers",
        "description": "Create a separate layer for each instance. If instances are used, realized curve geometry will be\nignored. Layer names will use the instance geometry name. If real curve geometry is used, a single\nlayer is created with the input geometry's name."
      }
    ],
    "outputs": [
      {
        "name": "Grease Pencil",
        "description": "Standard Grease Pencil geometry."
      }
    ]
  },
  "GeometryNodeReverseCurve": {
    "label": "Reverse Curve Node",
    "description": "The *Reverse Curve* node swaps the start and end of splines.\nThe shape of the splines is not changed.\nWhen used on the *Profile* input of the /modeling/geometry_nodes/curve/operations/curve_to_mesh,\nthis node fill flip the normals of the resulting mesh.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/reverse_curve.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Whether or not to change the direction of each spline. True values mean the direction will be changed,\nfalse values mean the spline will be unaffected."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "When used on the *Profile* input of the /modeling/geometry_nodes/curve/operations/curve_to_mesh,"
      }
    ]
  },
  "GeometryNodeTrimCurve": {
    "label": "Trim Curve Node",
    "description": "The *Trim Curve* node shortens each spline in the curve by removing sections at\nthe start and end of each spline.\nB\u00e9zier splines will still be B\u00e9zier splines in the output, with the first and last control point and\nits handles moved as necessary to preserve the shape.\nNURBS splines will be transformed into poly splines in order to be trimmed.\nCurrently the Trim Curve node does not support\ncyclic splines.\nSince curve normals are calculated the final curve,\nthis node may change the resulting normals when the Minimum twist method is used, since the Minimum\nmethod considers the entire length of the curve to decide the final normals. In some cases the\n/modeling/geometry_nodes/attribute/capture_attribute could be used to avoid this,\nby saving the original normals to be used later.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/trim_curve.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input with a curve component."
      },
      {
        "name": "Selection",
        "description": "A boolean field input for each curve indicating whether it is trimmed or not."
      },
      {
        "name": "Start",
        "description": "The factor or length used to determine where to start each output spline.\nIf the *Start* input is larger than the *End*, then the resulting spline\nwill have a single point, located at the sample location of the *Start* value."
      },
      {
        "name": "End",
        "description": "The factor or length used to determine where to end each output spline."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Mode\nHow to find endpoint positions for the trimmed spline.\nFind the endpoint positions using a factor of each spline's length.\nThe input values should be between 0 or 1.\nFind the endpoint positions using a length from the start of each spline.\nThe input values should be between 0 and the length of the splines.",
    "notes": [
      {
        "type": "warning",
        "text": "Currently the Trim Curve node does not support"
      },
      {
        "type": "note",
        "text": "Since curve normals are calculated the final curve,"
      },
      {
        "type": "note",
        "text": "If the *Start* input is larger than the *End*, then the resulting spline"
      }
    ]
  },
  "GeometryNodeCurveToMesh": {
    "label": "Curve to Mesh Node",
    "description": "The Curve to Mesh node converts all splines of a curve to a mesh.\nOptionally, a profile curve can be provided to give the curve a custom shape.\nThe node transfers attributes to the result. Attributes that are built-in on meshes but not curves,\nlike ``sharp_face``, will be transferred to the correct domain as well.\nThe output mesh has sharp edges set from\nthe profile curve tagged automatically. If any splines in the profile curve\nare B\u00e9zier splines and any of the control points use *Free* or *Vector* handles,\nthe corresponding edges will be shaded sharp.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/curve_to_mesh.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input.\nAll non-curve components are ignored."
      },
      {
        "name": "Profile Curve",
        "description": "If a profile curve is provided, it will be extruded along all splines.\nOtherwise the generated mesh will just be a chain of edges."
      },
      {
        "name": "Scale",
        "description": "The scale used at each control point of the input curve to scale the profile curve."
      },
      {
        "name": "Fill Caps",
        "description": "If the profile spline is cyclic, fill the ends of the generated mesh with n-gons.\nThe resulting mesh is Manifold, the two new faces for each spline are\nsimply connected to existing edges."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "The output mesh has sharp edges set from"
      }
    ]
  },
  "GeometryNodeSubdivideCurve": {
    "label": "Subdivide Curve Node",
    "description": "The *Subdivide Curve* node adds more control points in between existing control points on the curve input.\nFor B\u00e9zier and poly splines, the shape of the spline will not be changed at all.\nWith B\u00e9zier curves, this can be used to increase the control on the shape of the curve\nwhile still having the higher-level provided by B\u00e9zier splines.\nUnlike the /modeling/geometry_nodes/curve/operations/resample_curve, where they are converted to poly splines.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/subdivide_curve.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input."
      },
      {
        "name": "Cuts",
        "description": "The number of control points to create on the segment following each point.\nWhen the input is a field, the number of cuts for a segment is determined by\nthe value of the field when evaluated at the previous point."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeDeformCurvesOnSurface": {
    "label": "Deform Curves on Surface Node",
    "description": "The *Deform Curves on Surface* node translates and rotates each curve based on the\ndifference in its root position. The root position is defined by UV coordinates stored\non each curve and the UV Map selected for the purpose in the\nCurves surface settings.\nThe transformation is calculated based on the difference of the original mesh\n(before shape keys and modifiers are evaluated), and the final mesh.\nUnlike other geometry nodes, this node has quite a few implicit inputs:\n- The original and evaluated mesh are retrieved from the modifier object's surface\nproperty. This means the node only works for curves objects.\n- The original and evaluated UV map are also retrieved from the object's surface property.\n- A 3D vector attribute named ``rest_position``, used for calculating tangents for rotating\ncurves that are consistent with the tangents calculated on the original mesh (the rotation\nneeds to be calculated from the normal and tangent of the original and evaluated meshes).\n- A 2D vector attribute on the curve domain named ``surface_uv_coordinate`` to store the\nlocation of the root positions on the surface mesh's UV map.\nIn future development, this node will be generalized so the setup is more flexible.\nParts of the internal operation are similar to the /modeling/geometry_nodes/mesh/sample/sample_uv_surface.\nIn order to achieve consistent deformation after the /modeling/modifiers/generate/subdivision_surface,\nthe *UV Smooth* option of the modifier should be set to *None*. Otherwise the surface UV map will\nbe subdivided in a way that may invalidate the curve UV attachement points stored in the\n``surface_uv_coordinate`` attribute.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/deform_curves_on_surface.rst",
    "inputs": [
      {
        "name": "Curves",
        "description": "Standard curves input."
      }
    ],
    "outputs": [
      {
        "name": "Curves",
        "description": "Standard curves output."
      }
    ],
    "notes": [
      {
        "type": "warning",
        "text": "In order to achieve consistent deformation after the /modeling/modifiers/generate/subdivision_surface,"
      }
    ]
  },
  "GeometryNodeCurveToPoints": {
    "label": "Curve to Points Node",
    "description": "The *Curve to Points* node generates a point cloud from a curve.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/curve_to_points.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard curve input."
      },
      {
        "name": "Count",
        "description": "Number of points generated. This input is only available for *Count* mode."
      },
      {
        "name": "Length",
        "description": "Length of the curve. This input is only available for *Length* mode."
      }
    ],
    "outputs": [
      {
        "name": "Points",
        "description": "Generated point cloud."
      },
      {
        "name": "Tangent",
        "description": "The normalized curve tangent at the sampled\nposition, or the direct evaluated normal in *Evaluated* mode."
      },
      {
        "name": "Normal",
        "description": "The normal value from the evaluated curve at each result point.\nThis is the same value from the /modeling/geometry_nodes/geometry/read/normal\nat those positions."
      },
      {
        "name": "Rotation",
        "description": "The Euler rotation build from the *Tangent* and *Normal* outputs, for convenience."
      }
    ],
    "properties": "Mode\nCreates points from the curve's evaluated points based on\nthe resolution attribute\nfor NURBS and B\u00e9zier splines. This mode will generally be the fastest,\nsince the second step of sampling equal lengths is not necessary.\nSample each spline by evenly distributing the specified number of points.\nSample each spline by splitting it into segments with specified length.\nThe length will be rounded down so that a whole number of samples will fit in\neach input spline. To counteract jumping when the length of the spline changes,\nthe /modeling/geometry_nodes/curve/operations/trim_curve can be used with\na multiple of this length."
  },
  "GeometryNodeFillCurve": {
    "label": "Fill Curve Node",
    "description": "The *Fill Curve* node generates a mesh using the constrained Delaunay triangulation algorithm\nwith the curves as boundaries. The mesh is only generated flat with a local Z of 0.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/fill_curve.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input with a curve component."
      },
      {
        "name": "Group ID",
        "description": "Value used to group curves together.\nCurves with different Group ID are treated separately."
      },
      {
        "name": "Mode",
        "description": "The type of geometry the output consists of."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "The filled-in curves."
      }
    ]
  },
  "GeometryNodeFilletCurve": {
    "label": "Fillet Curve Node",
    "description": "The *Fillet Curve* rounds corners on curve control points, similar to the effect of\nthe Bevel Modifier on a 2D mesh.\nHowever, a key difference is that the rounded portions created by the Fillet Curve node\nare always portions of a circle.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/fillet_curve.rst",
    "inputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input with a curve component."
      },
      {
        "name": "Radius",
        "description": "The radius of the circle portion generated at each fillet."
      },
      {
        "name": "Count",
        "description": "Only in *Poly* mode, the number of control points to add for each fillet."
      },
      {
        "name": "Limit Radius",
        "description": "Whether to limit the maximum value of the radius in order to avoid overlapping fillets."
      },
      {
        "name": "Mode",
        "description": "How to choose number of vertices on fillet\nOnly two control points will be generated for every filleted control point. The shape generated\nby the aligned handles on the generated control points on either side of the fillet is used to\ncreate the circle portion shape, meaning that the number of segments in the fillet shape depends on\nthe spline's resolution value.\nThe number of control points generated for each field\ninput is controlled directly with an integer field input.\nThis mode works better for poly and NURBS splines."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry input with a curve component."
      }
    ]
  },
  "GeometryNodeInterpolateCurves": {
    "label": "Interpolate Curves Node",
    "description": "Generate new curves on points by interpolating between existing curves.\nThis is useful to have a smaller set of original curves to make editing easier and faster\nwhile still generating high-density curves for the viewport or a final render.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/operations/interpolate_curves.rst",
    "inputs": [
      {
        "name": "Guide Curves",
        "description": "Base curves that new curves are interpolated between."
      },
      {
        "name": "Guide Up",
        "description": "Optional up vector that is typically a surface normal. Supplying an up vector will improve\nthe quality of the interpolation, making it aware of the surface shape which it otherwise\nwouldn't have a way to know about.\nIn a typical \"child hair\" generation setup, this up direction is retrieved with a combination\nof the /modeling/geometry_nodes/mesh/sample/sample_uv_surface using the same geometry\nthat the points were distributed on, and the /modeling/geometry_nodes/geometry/read/normal."
      },
      {
        "name": "Guide Group ID",
        "description": "Splits guides into separate groups. New curves interpolate existing curves from a single group.\nThis input can be useful for generating hair parts by stopping curves in different sections\n(with different group IDs) from affecting each other."
      },
      {
        "name": "Points",
        "description": "The positions of the first root control points of the newly generated interpolated curves."
      },
      {
        "name": "Points Up",
        "description": "Optional up vector that is typically a surface normal."
      },
      {
        "name": "Point Group ID",
        "description": "The curve group to interpolate in."
      },
      {
        "name": "Max Neighbors",
        "description": "Maximum amount of close guide curves that are taken into account for interpolation."
      }
    ],
    "outputs": [
      {
        "name": "Curves",
        "description": "The guide curves with interpolated curves."
      },
      {
        "name": "Closest Index",
        "description": "Index of the closest guide curve for each generated curve.\nInternally this node mixes the data from multiple guide curves, with the maximum number\nof sources depending on the *Max Neighbors* input. This output is only the index of the curve\nwith the largest weight."
      },
      {
        "name": "Closest Weight",
        "description": "Weight of the closest guide curve for each generated curve."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "In a typical \"child hair\" generation setup, this up direction is retrieved with a combination"
      },
      {
        "type": "note",
        "text": "Internally this node mixes the data from multiple guide curves, with the maximum number"
      }
    ]
  },
  "GeometryNodeCurvePrimitiveLine": {
    "label": "Curve Line Node",
    "description": "The *Curve Line* node generates poly spline line.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/primitives/curve_line.rst",
    "inputs": [
      {
        "name": "Start",
        "description": "Position of the first control point."
      },
      {
        "name": "End",
        "description": "Position of the second control point.\nThis is only available in the *Points* mode."
      },
      {
        "name": "Direction",
        "description": "Direction the line is going in.\nThe length of this vector does not matter.\nThis is only available in the *Direction* mode."
      },
      {
        "name": "Length",
        "description": "Length of the line.\nThis is only available in the *Direction* mode."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Mode:\nDefine the spline with start and end points.\nDefine the spline with a start, direction and length."
  },
  "GeometryNodeCurvePrimitiveCircle": {
    "label": "Curve Circle Node",
    "description": "The *Curve Circle* node generates a poly spline circle.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/primitives/curve_circle.rst",
    "inputs": [
      {
        "name": "Resolution",
        "description": "Number of edges on the circle."
      },
      {
        "name": "Radius",
        "description": "The radius of the circle."
      },
      {
        "name": "Point 1, Point 2, Point 3",
        "description": "The three points on the circle.\nThe order of the points determines the direction (clockwise or counterclockwise) of the circle."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Poly spline generated from the inputs."
      },
      {
        "name": "Center",
        "description": "The center of the circle defined by the three points."
      }
    ],
    "properties": "Mode\nThe position and radius of the circle are determined by three points.\nThe center of the circle is also given as an output.\nIf the three points lie on one line, no geometry is generated.\nThe circle is determined by the radius.",
    "notes": [
      {
        "type": "note",
        "text": "Because of the finite resolution, the three points do not necessarily lie on the generated curve."
      }
    ]
  },
  "GeometryNodeCurvePrimitiveQuadrilateral": {
    "label": "Quadrilateral Node",
    "description": "The *Quadrilateral* node generates a polygon with four points, with different modes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/primitives/quadrilateral.rst",
    "inputs": [
      {
        "name": "Width / Bottom Width / Top Width",
        "description": "The X axis size of the shape."
      },
      {
        "name": "Height",
        "description": "The Y axis size of the shape."
      },
      {
        "name": "Bottom Height / Top Height",
        "description": "The distance between the bottom or top point and the X axis, in *Kite* mode."
      },
      {
        "name": "Offset",
        "description": "In *Parallelogram* mode, the relative X difference between the top and bottom edge.\nIn *Trapezoid* mode, the amount to move the top edge in the positive X axis."
      },
      {
        "name": "Point 1 - 4",
        "description": "Input vectors for the *Points* mode."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Poly spline generated from the inputs."
      }
    ],
    "properties": "Mode\nGenerate a rectangle-shaped curve with a width and a height.\nGenerate a rectangle with an offset for the different X values of the top and bottom edges.\nGenerate a trapezoid-shaped curve with a height, a width for the top and bottom, and an offset.\nGenerate a kite shape with a width, and the top and bottom points distance from the X axis.\nGenerate a four point cyclic poly spline by inputting the position vectors directly."
  },
  "GeometryNodeCurveQuadraticBezier": {
    "label": "Quadratic B\u00e9zier Node",
    "description": "The *Quadratic B\u00e9zier* node generates a poly spline curve from the given control points.\nThe generated shape is a parabola.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/primitives/quadratic_bezier.rst",
    "inputs": [
      {
        "name": "Resolution",
        "description": "The number of edges on the curve."
      },
      {
        "name": "Start, Middle, End",
        "description": "Positions of the three control points.\nThe generated curve passes through the two end points, and is tangent to the lines between\nthe middle point and the two end points."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Poly spline generated from the inputs."
      }
    ]
  },
  "GeometryNodeCurveStar": {
    "label": "Star Node",
    "description": "The *Star* node generates a poly spline in a star pattern by connecting alternating points of two circles.\nThe points on the inner circle are offset by a rotation so that they lie in between the points on the outer circle.\nThis offset can be changed with the twist input.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/primitives/star.rst",
    "inputs": [
      {
        "name": "Points",
        "description": "Number of points on each of the circles."
      },
      {
        "name": "Inner Radius, Outer Radius",
        "description": "Radii of the two circles on which to place the control points.\nThe inner radius can be larger than the outer radius."
      },
      {
        "name": "Twist",
        "description": "Angle offset of the inner circle.\nThe twist value rotates the points on the circle corresponding with the inner radius\ncounterclockwise by the given angle."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Poly spline generated from the inputs."
      },
      {
        "name": "Outer Points",
        "description": "A boolean attribute field with a selection of the points on the *Outer Radius*, which is every\nother point."
      }
    ]
  },
  "GeometryNodeCurveArc": {
    "label": "Arc Node",
    "description": "The *Arc* node generates a poly spline arc. The node has two modes, Radius and Points.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/primitives/arc.rst",
    "inputs": [
      {
        "name": "Resolution",
        "description": "Number of edges on the arc."
      },
      {
        "name": "Radius",
        "description": "The radius of the arc. *Radius* mode only."
      },
      {
        "name": "Start Angle",
        "description": "Starting angle of the arc.  *Radius* mode only."
      },
      {
        "name": "Sweep Angle",
        "description": "Length of the arc.   *Radius* mode only."
      },
      {
        "name": "Connect Center",
        "description": "Connect the arc at the center."
      },
      {
        "name": "Invert Arc",
        "description": "Invert and draw opposite arc."
      },
      {
        "name": "Start, Middle, End",
        "description": "The three points on the arc. *Points* mode only.\nThe order of the points determines the direction (clockwise or counterclockwise) of the arc.\nThe arc will always draw from Start to End via the Middle point. This can be changed by using\nthe Invert Arc option."
      },
      {
        "name": "Offset Angle",
        "description": "Offset angle of the arc. *Points* mode only."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Poly spline generated from the inputs."
      },
      {
        "name": "Center",
        "description": "The center of the arc described by the three points. *Points* mode only."
      },
      {
        "name": "Normal",
        "description": "The normal direction of the plane described by the three points,\npointing towards the positive Z axis. *Points* mode only."
      },
      {
        "name": "Radius",
        "description": "The radius of the arc described by the three points. *Points* mode only."
      }
    ],
    "properties": "Mode\nThe position and radius of the arc are determined by three points.\nThe center of the arc, radius and normal are also given as outputs.\nThe arc is determined by the radius, start angle and sweep angle.",
    "notes": [
      {
        "type": "note",
        "text": "Because of the finite resolution, the middle point does not necessarily lie on the generated arc."
      }
    ]
  },
  "GeometryNodeCurveSpiral": {
    "label": "Spiral Node",
    "description": "The *Spiral* node generates a poly spline in a spiral shape.\nIt can be used to create springs or other similar objects.\nBy default the spiral twists in a clockwise fashion.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/primitives/curve_spiral.rst",
    "inputs": [
      {
        "name": "Resolution",
        "description": "Number of points in one rotation of the spiral."
      },
      {
        "name": "Rotations",
        "description": "Number of times the spiral makes a full rotation."
      },
      {
        "name": "Start Radius, End Radius",
        "description": "Radius of the start point and end point of the spiral.\nThe radius of the spiral changes linearly between the two values over the whole spiral."
      },
      {
        "name": "Height",
        "description": "Height of the spiral."
      },
      {
        "name": "Reverse",
        "description": "Boolean value that changes the direction from clockwise to counterclockwise when it is enabled."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "Poly spline generated from the inputs."
      }
    ]
  },
  "GeometryNodeCurvePrimitiveBezierSegment": {
    "label": "B\u00e9zier Segment Node",
    "description": "The *B\u00e9zier Segment* node generates a 2D B\u00e9zier spline from the given control points and handles.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/primitives/bezier_segment.rst",
    "inputs": [
      {
        "name": "Resolution",
        "description": "The number of edges on the curve."
      },
      {
        "name": "Start, End",
        "description": "Positions of the start and end control point of the curve."
      },
      {
        "name": "Start Handle, End Handle",
        "description": "Positions of the handles used to define the shape of the curve."
      }
    ],
    "outputs": [
      {
        "name": "Curve",
        "description": "B\u00e9zier spline generated from the inputs."
      }
    ],
    "properties": "Mode\nThe handle inputs are the absolute positions of the handles in 3D space.\nThe handle positions are relative to the control point on the curve.\nThe handle inputs give the offset from the control points."
  },
  "GeometryNodeSampleCurve": {
    "label": "Sample Curve Node",
    "description": "The *Sample Curve* calculates a point on a curve at a certain distance from the start of the curve,\nspecified by the length or factor inputs. It also outputs data retrieved from that position on the curve.\nThe sampled values are linearly interpolated from the values at the evaluated curve points\nat each side of the sampled point.\nWhen the curve contains multiple splines, the sample position is found based on the total accumulated length,\nincluding the lengths of all previous splines. The order of the splines is the same order as\ndisplayed in the Spreadsheet Editor.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/curve/sample/sample_curve.rst",
    "inputs": [
      {
        "name": "Curves",
        "description": "Standard geometry input with a curve component."
      },
      {
        "name": "Value",
        "description": "A field input to evaluate custom attributes.\nThe evaluation is outputted through the *Value* output."
      },
      {
        "name": "Factor Factor mode",
        "description": "The portion of the total length used to determine the sample position."
      },
      {
        "name": "Length Length mode",
        "description": "A length in distance units used to determine how far along the curve to travel before sampling."
      },
      {
        "name": "Curve Index",
        "description": "An index to only evaluate specific splines, these indices can be specified manually\nor from the /modeling/geometry_nodes/geometry/read/input_index.\nThis input is ignored when the *All Curves* property is enabled."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "The value of the input *Value* at the sample point."
      },
      {
        "name": "Position",
        "description": "The position at the sample along the spline."
      },
      {
        "name": "Tangent",
        "description": "The normalized curve tangent at the sample.\nThis output can be combined with the /modeling/geometry_nodes/utilities/rotation/align_rotation_to_vector\nto create a rotation that lines up with direction of the curve. Including the *Normal* output\nin a second align node after can align the other rotation axis."
      },
      {
        "name": "Normal",
        "description": "The normalized curve normal at the sample."
      }
    ],
    "properties": "Data Type\nThe data type used for the evaluated data.\nMode\nHow to find endpoint positions for the trimmed spline.\nThe option acts the same as it does in the /modeling/geometry_nodes/curve/operations/trim_curve.\nFind the endpoint positions using a factor of each spline's length.\nThe input values should be between 0 or 1.\nFind the endpoint positions using a length from the start of each spline.\nThe input values should be between 0 and the length of the splines.\nAll Curves\nSample lengths based on the total length of all curves, rather than using a length inside each selected curve.",
    "notes": [
      {
        "type": "note",
        "text": "When the curve contains multiple splines, the sample position is found based on the total accumulated length,"
      },
      {
        "type": "tip",
        "text": "This output can be combined with the /modeling/geometry_nodes/utilities/rotation/align_rotation_to_vector"
      }
    ]
  },
  "GeometryNodeSimulationInput": {
    "label": "GeometryNodeSimulationInput",
    "description": "",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/simulation/simulation_zone.rst"
  },
  "GeometryNodeSimulationOutput": {
    "label": "Simulation Zone",
    "description": "Simulation zones allow the result of one frame to influence the next one.\nThat way even a set of simple rules can lead to complex results, with the passing of time.\nThe most common type of them is physics simulation, with specific solvers for physical phenomena.\nInitial simulation nodes and simulation zone.\nWhen adding a simulation, two nodes are added, defining between them a \"Simulation Zone\".\nThe inputs that are connected to the Simulation Input node are evaluated only once,\nat the beginning of the simulation, passed to the next simulation state and eventually outputted.\nOther nodes can be linked inside the simulation region from the outside.\nThose are re-evaluated every step based on their value at the given frame.\nIt is not possible to have any link going towards outside.\nThe result of the simulation can only be accessed via the Simulation Output node.\nThis also allows sub-frame interpolation for motion blur.\nThis node cannot be used in the Tool context\u2014only in the *Modifier* context.\nAnonymous attributes are not propagated by the simulation nodes unless they are explicitly stored in the simulation\nstate. This is because detecting which anonymous attributes will be required for the simulation and afterwards\nwould require looking into the future to see what data is necessary.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/simulation/simulation_zone.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input, which is available by default to input geometry into the simulation zone.\nMore bake items can be added by dragging sockets into the blank socket or in the *Simulation State* panel.\nItems can be renamed by Ctrl-LMB on the socket name or in the nodes *Properties* panel."
      },
      {
        "name": "Delta Time",
        "description": "The time in seconds between frames.\nEssentially this the inverse of the render Frame Rate.\nThis delta is used to drive the simulation by connecting it node setups that depend on a rate.\nThis will keep the simulation playback consistent when the frame rate changes."
      },
      {
        "name": "Skip",
        "description": "Forward the output of the simulation input node directly\nto the output node and ignore the nodes in the simulation zone."
      }
    ],
    "properties": "In the Node Editor the inputs can be renamed, shuffled and removed.\nThis is also the place where sub-steps can be defined for a simulation.",
    "notes": [
      {
        "type": "note",
        "text": "This node cannot be used in the Tool context\u2014only in the *Modifier* context."
      },
      {
        "type": "note",
        "text": "Anonymous attributes are not propagated by the simulation nodes unless they are explicitly stored in the simulation"
      },
      {
        "type": "note",
        "text": "Baking the simulation will bake all the simulations in all modifiers for the selected objects."
      }
    ]
  },
  "GeometryNodeRepeatInput": {
    "label": "GeometryNodeRepeatInput",
    "description": "",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/repeat_zone.rst"
  },
  "GeometryNodeRepeatOutput": {
    "label": "Repeat Zone",
    "description": "A *Repeat Zone* executes a set of nodes multiple times.\nThe zone consists of an input node on the left, an output node on the right,\nand an orange area in the middle for placing the nodes to repeat. When the zone executes\nfor the first time, it evaluates its inputs and forwards them to its inner nodes.\nThese inner nodes can then write to the output node for providing inputs to the next\niteration, and for providing the result of the zone after the last iteration.\nThe nodes inside the zone can also take inputs from nodes outside the zone -- these\ninputs are then the same in every iteration. However, nodes inside the zone can't\nsend their outputs to nodes outside the zone.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/repeat_zone.rst",
    "inputs": [
      {
        "name": "Iterations",
        "description": "Number of times to execute the zone. The *Iteration* socket gives the index of\nthe current iteration, starting from 0."
      },
      {
        "name": "Geometry",
        "description": "Default geometry input. Further inputs can be added by connecting a node's output\nto the zone's blank input, or by using the *Repeat Items* list in the node's\n*Properties* panel.\nThe inputs can be renamed by clicking them with Ctrl-LMB in the zone\nitself or in the *Repeat Items* list. The latter also accepts double clicking."
      }
    ],
    "properties": "Menu Sidebar --> Node --> Properties\nRepeat Items\nui-list-view for adding, removing, reordering, and renaming the inputs of the zone.\nSocket Type\nThe data type of the selected input.\nInspection Index\nThe number of the iteration to show in socket inspection\nand in the /modeling/geometry_nodes/output/viewer."
  },
  "FunctionNodeRandomValue": {
    "label": "Random Value Node",
    "description": "The *Random Value* node outputs a white noise like value as a *Float*, *Integer*, *Vector*, or *Boolean* field.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/random_value.rst",
    "inputs": [
      {
        "name": "Min",
        "description": "The minimum value of the range where random values are sampled from.\nThis input is only available for *Float*, *Integer*, and *Vector* types."
      },
      {
        "name": "Max",
        "description": "The maximum value of the range where random values are sampled from.\nThis input is only available for *Float*, *Integer*, and *Vector* types."
      },
      {
        "name": "Probability",
        "description": "The probability ratio for the random *Boolean* output to be *True*.\nThis input is only available for *Boolean* types."
      },
      {
        "name": "ID",
        "description": "An ID to drive the random number generator seed. By default, this input uses the same value\nas of the /modeling/geometry_nodes/geometry/read/id, which is the ``id`` attribute of the context\ngeometry if it exists, and otherwise the index.\nBy default, the random value node generates a value for each unique index.\nIf a single random value is desired, connect a single value\n(such as an /modeling/geometry_nodes/input/constant/integer ) to the ID input."
      },
      {
        "name": "Seed",
        "description": "A field to Seed the random number generator. This can be used to generate\na different set of random values, even for two nodes with the same *ID* input."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "Random values as a field."
      }
    ],
    "properties": "Data Type"
  },
  "GeometryNodeMenuSwitch": {
    "label": "Menu Switch Node",
    "description": "The *Menu Switch* node outputs one of its inputs based on a selected menu item.\nOnly the active input is evaluated, allowing efficient switching between multiple options.\nThe available menu entries are defined by the user. Menu items can be\nadded and removed, as well as renamed and reordered in the editor side\nbar. Renaming a menu entry keeps existing links of the matching input\nsocket.\nThe menu can be used in node groups and the nodes modifier UI.\nConnecting the menu input with a *Group Input* node will expose the menu\nas a group input. A menu socket in a node group, reroute node, or other\npass-through nodes needs to be connected to a *Menu Switch* node in\norder to work. An unconnected menu socket will show an empty menu by\ndefault.\nConnecting multiple *Menu Switch* nodes to the same output\nsocket creates a conflict (even when the menu entries are the same).\nTo avoid this a menu switch can be wrapped in a node group. Multiple\nnode groups of the same type can be connected to the same menu, since\nthey contain the same menu switch node.\n* - .. figure:: /images/node-types_GeometryNodeMenuSwitch_conflict.webp\nConflict caused by connecting different menus.\n- .. figure:: /images/node-types_GeometryNodeMenuSwitch_group_wrapper.webp\nSame node group can be connected without conflict.\nThe /modeling/geometry_nodes/utilities/index_switch\nis similar but it exposes the choices as an integer index.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/menu_switch.rst",
    "inputs": [
      {
        "name": "Menu",
        "description": "Determines which input socket is passed through to the output."
      },
      {
        "name": "One input is created for each menu entry. The input corresponding to the selected menu item",
        "description": ""
      },
      {
        "name": "is evaluated and passed through.",
        "description": ""
      },
      {
        "name": "Menu item labels can be renamed using Ctrl-LMB on the socket name or in the node's *Properties* panel.",
        "description": ""
      },
      {
        "name": "Additional input sockets can be added by:",
        "description": ""
      },
      {
        "name": "- Dragging a connection onto the empty socket at the bottom of the list.",
        "description": ""
      },
      {
        "name": "- Clicking the add icon in the node header.",
        "description": ""
      },
      {
        "name": "Unused inputs are not computed, improving performance in complex node networks.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Output",
        "description": "Outputs the value from the input corresponding to the selected menu item, unchanged."
      },
      {
        "name": "For each menu entry, an additional Boolean output is created.",
        "description": ""
      },
      {
        "name": "The output corresponding to the selected item is *true*, and all others are *false*.",
        "description": ""
      },
      {
        "name": "These Boolean outputs can be used to trigger different node branches, control visibility,",
        "description": ""
      },
      {
        "name": "or drive conditional operations elsewhere in the node tree.",
        "description": ""
      }
    ],
    "properties": "Type\nDetermines the type of the data that is handled by the node."
  },
  "GeometryNodeSwitch": {
    "label": "Switch Node",
    "description": "The *Switch* node outputs one of two inputs depending on a condition.\nOnly the input that is passed through the node is computed.\nThe /modeling/geometry_nodes/utilities/menu_switch\nand /modeling/geometry_nodes/utilities/index_switch\ncan be used to switch between an arbitrary amount of inputs.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/switch.rst",
    "inputs": [
      {
        "name": "Switch",
        "description": "Determines which of the two inputs below will be passed through."
      },
      {
        "name": "False",
        "description": "Is passed through when the switch is set to false."
      },
      {
        "name": "True",
        "description": "Is passed through when the switch is set to true."
      }
    ],
    "outputs": [
      {
        "name": "Output",
        "description": "One of the two inputs without any modifications."
      }
    ],
    "properties": "Type\nDetermines the type of the data that is handled by the node."
  },
  "GeometryNodeForEachGeometryElementInput": {
    "label": "GeometryNodeForEachGeometryElementInput",
    "description": "",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/for_each_geometry_zone.rst"
  },
  "GeometryNodeForEachGeometryElementOutput": {
    "label": "For Each Geometry Element Zone",
    "description": "This zone type allows executing nodes for each element of a geometry. For example, the nodes can process\nevery face of a mesh, or every instance.\nThe *For Each Element* zone.\nThe zone is ideal for tasks that generate large or complex geometry for every element of an input geometry.\nFor example, generating a unique tree for every input curve, or a unique building on every input face.\nThe zone makes less sense for processing small amounts of geometry. In that case (for example each of a character's\nhairs separately) it will likely always be slower than working on fewer larger geometries. The additional\nflexibility from processing each element separately comes at the cost that Blender can't optimize the operation\nas well. For node groups that need to handle lots of geometry elements, it's recommended to design the node setup\nso that iteration over tiny sub-geometries is not required.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/for_each_geometry_zone.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Geometry whose elements are iterated over."
      },
      {
        "name": "Selection",
        "description": "Which subset of the chosen *Domain* to process."
      },
      {
        "name": "Index",
        "description": "Index of the element in the source geometry. Note that the same index can occur more than\nonce when iterating over multiple geometry component types at once."
      },
      {
        "name": "Element",
        "description": "The input geometry is split up into a separate geometry for each element.\nThis is the single element geometry for the current iteration. This is not available\nfor the *Face Corner* domain, since face corners cannot exist without their face.\nIt can be quite inefficient to split up large geometries into many small elements.\nBecause this output isn't computed if it's not used in the node graph, not using it\nwill typically improve performance."
      }
    ],
    "outputs": [
      {
        "name": "The *Main Geometry* outputs create attributes on the \"main\" output geometry (the first output).",
        "description": ""
      },
      {
        "name": "Every single value on the inside of the zone becomes a value of the attribute at the current index.",
        "description": ""
      },
      {
        "name": "The outputs in the *Generated* panel, including the default *Geometry* output are joined together from the",
        "description": ""
      },
      {
        "name": "geometry generated from each element. Any non-geometry type below a specific geometry in this list will output",
        "description": ""
      },
      {
        "name": "as an anonymous attribute on that joined geometry (and not the others).",
        "description": ""
      },
      {
        "name": "Attributes from the zone's input geometry are also propagated to these geometry outputs.",
        "description": ""
      }
    ],
    "properties": "Domain\nWhich attribute domain to process.\nInspection Index\nGeometry element index that is used by inspection features like the /modeling/geometry_nodes/output/viewer\nor socket inspection.",
    "notes": [
      {
        "type": "note",
        "text": "It can be quite inefficient to split up large geometries into many small elements."
      }
    ]
  },
  "GeometryNodeIndexSwitch": {
    "label": "Index Switch Node",
    "description": "The *Index Switch* node outputs one of its inputs based on an integer *Index* value.\nOnly the selected input is evaluated, making this node useful for switching between\nmultiple data inputs efficiently.\nThe Menu Switch node provides similar functionality,\nbut exposes the selection as a user-friendly menu rather than an index.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/index_switch.rst",
    "inputs": [
      {
        "name": "Index",
        "description": "Determines which of the following input sockets is passed through to the output.\nThe index is zero-based (i.e., the first input corresponds to index 0)."
      },
      {
        "name": "Each socket represents a possible input to select from.",
        "description": ""
      },
      {
        "name": "The active input is determined by the *Index* value.",
        "description": ""
      },
      {
        "name": "Additional input sockets can be added by either:",
        "description": ""
      },
      {
        "name": "- Dragging a connection onto the empty socket at the bottom of the list.",
        "description": ""
      },
      {
        "name": "- Clicking the add icon in the node header.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Output",
        "description": "Outputs the value from the input corresponding to the current *Index* value,\nwithout any modification.\nIf the *Index* value is outside the range of available inputs, the output defaults\nto the first input or a zero-equivalent value, depending on the data type."
      }
    ],
    "properties": "Type\nDetermines the type of the data that is handled by the node.",
    "notes": [
      {
        "type": "tip",
        "text": "When the *Index* input is connected to a Menu Switch node"
      }
    ]
  },
  "GeometryNodeFieldVariance": {
    "label": "Field Variance Node",
    "description": "The *Field Variance* node computes the variance and standard deviation of a field over a given domain.\nThis is useful for measuring how much a value varies across geometry or within specific groups.\nFor example, it can be used to analyze the spread of values like weights, positions, or custom attributes\nwithin each group defined by the *Group ID*.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/field/field_variance.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "The field to evaluate. Can be a float or a vector depending on the *Data Type*.\nFor vector values, variance is computed separately per component (X, Y, Z)."
      },
      {
        "name": "Group ID",
        "description": "An index used to group values together for multiple separate variances.\nThis can be thought of as a choice of the \"bin\" in which to place each value.\nThis input has no effect when it is only a single value."
      }
    ],
    "properties": "Data Type\nDomain\nThe attribute domain used for evaluate the *Value* input."
  },
  "GeometryNodeFieldAtIndex": {
    "label": "Evaluate at Index Node",
    "description": "The *Evaluate at Index* node allows accessing data of other elements in the context geometry.\nIt is similar to the /modeling/geometry_nodes/geometry/sample/sample_index.\nThe main difference is that this node does not require a geometry input, because the geometry\nfrom the field context is used.\nThis node is also similar to the /modeling/geometry_nodes/utilities/field/evaluate_on_domain node,\nexcept that the value to retrieve from the specified domain is specified by an index rather than\nan automatic domain interpolation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/field/evaluate_at_index.rst",
    "inputs": [
      {
        "name": "Index",
        "description": "The index of the element in the selected domain\nto retrieve data from, i.e. \"the fourth face\", or \"the first control point\"."
      },
      {
        "name": "Value",
        "description": "The field to retrieve data from."
      }
    ],
    "properties": "Domain\nThe attribute domain used for evaluation of the *Value* input.\nThis is useful because it can be a different domain than the domain from the\nfield context, i.e. to choose a vertex for each face."
  },
  "GeometryNodeFieldOnDomain": {
    "label": "Evaluate on Domain Node",
    "description": "The *Evaluate on Domain* allows evaluating a field for a different attribute domain\nthan the domain from the field context. For example, the face index could be used instead\nof the face corner index, when setting the values of a UV Map\nThis node is not necessary to retrieve data from other attribute domains; that is done automatically.\nIts utility comes from the fact that it's possible to control *when* the domain interpolation happens.\nNormally, input nodes interpolate their data to the current context's domain as soon as they create\ntheir output.\nIt may be preferable to use this node over the /modeling/geometry_nodes/attribute/capture_attribute,\nsince it allows using a specific attribute domain without requiring a geometry socket input,\nwhich allows creating more reusable node groups.\nThe method of retrieving data from another domain is somewhat similar to the\n/modeling/geometry_nodes/utilities/field/evaluate_at_index.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/field/evaluate_on_domain.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "The field to evaluate on the chosen attribute domain."
      }
    ],
    "properties": "Domain\nThe attribute domain used for evaluation of the *Value* input.",
    "notes": [
      {
        "type": "note",
        "text": "This node is not necessary to retrieve data from other attribute domains; that is done automatically."
      },
      {
        "type": "tip",
        "text": "It may be preferable to use this node over the /modeling/geometry_nodes/attribute/capture_attribute,"
      }
    ]
  },
  "GeometryNodeFieldMinAndMax": {
    "label": "Field Min & Max Node",
    "description": "The *Field Min & Max* calculates the minimum and maximum of a given field.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/field/field_min_max.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "The values the minimum and maximum will be calculated from"
      },
      {
        "name": "Group ID",
        "description": "An index used to group values together for multiple separate averages.\nThis can be thought of as a choice of the \"bin\" in which to place each value.\nThis input has no effect when it is only a single value."
      }
    ],
    "properties": "Data Type\nDomain\nThe attribute domain used for evaluate the *Value* input."
  },
  "GeometryNodeAccumulateField": {
    "label": "Accumulate Field Node",
    "description": "The *Accumulate Field* node counts a running total of its input values, in the order defined\nby the geometry's indices. The node's essential\noperation is just addition, but instead of only outputting the final total, it outputs the current\nvalue at every element.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/field/accumulate_field.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "The values to be accumulated.\nWhen accumulating integer values, be careful to make sure that there are not\ntoo many large values. The maximum integer that Blender stores internally is\naround 2 billion. After that, values may wrap around and become negative.\nSee `Wikipedia <https://en.wikipedia.org/wiki/Integer_%28computer_science%29>`__\nfor more information."
      },
      {
        "name": "Group Index",
        "description": "An index used to group values together for multiple separate accumulations.\nThis can be thought of as a choice of the \"bin\" in which to place each value.\nThis input has no effect when it is only a single value."
      }
    ],
    "properties": "Data Type\nDomain\nThe attribute domain used for accumulation\nand for evaluation of the *Value* input.",
    "notes": [
      {
        "type": "warning",
        "text": "When accumulating integer values, be careful to make sure that there are not"
      }
    ]
  },
  "GeometryNodeFieldAverage": {
    "label": "Field Average Node",
    "description": "The *Field Average* calculates the mean and median of a given field.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/field/field_average.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "The values the mean and median will be calculated from."
      },
      {
        "name": "Group ID",
        "description": "An index used to group values together for multiple separate averages.\nThis can be thought of as a choice of the \"bin\" in which to place each value.\nThis input has no effect when it is only a single value."
      }
    ],
    "properties": "Data Type\nDomain\nThe attribute domain used for evaluate the *Value* input."
  },
  "FunctionNodeHashValue": {
    "label": "Hash Value Node",
    "description": "The *Hash Value* node takes a value input and hashes this to\nan integer.\nHashes cannot be relied upon to be used as unique\nidentifiers because they are not guaranteed to be unique.\nIt can be used to generate somewhat stable randomness\nespecially in cases where *White Noise* does not offer\nenough flexibility.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/math/hash_value.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "Value input determined by *Data Type* property."
      },
      {
        "name": "Seed",
        "description": "Integer input used to generate different Hashes\t."
      }
    ],
    "properties": "Data Type\nThe data type that is used for the *Value* input.\nThe node supports float, integer, vector, color,\nboolean, rotation, matrix and string data types."
  },
  "FunctionNodeIntegerMath": {
    "label": "Integer Math Node",
    "description": "The *Integer Math* node performs math operations.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/math/integer_math.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "Standard integer value input. Depending on the operation\nthere will be more than one input."
      }
    ],
    "properties": "Operation\nThe mathematical operator to be applied to the input values:\nFunctions\nThe input value is read without regard to its sign.\nThis turns negative values into positive values.\nComparison\nExtracts the sign of the input value. All positive numbers\nwill output 1. All negative numbers will output -1. And 0 will output 0.\nRounding"
  },
  "FunctionNodeBooleanMath": {
    "label": "Boolean Math Node",
    "description": "The *Boolean Math* node performs a basic logical operation on its inputs.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/math/boolean_math.rst",
    "inputs": [
      {
        "name": "Boolean",
        "description": "Two standard Boolean inputs."
      }
    ],
    "properties": "Mode\nTrue when both inputs are true.\n(`AND <https://en.wikipedia.org/wiki/AND_gate>`__)\nTrue when at least one input is true.\n(`OR <https://en.wikipedia.org/wiki/OR_gate>`__)\nOpposite of the input.\n(`NOT <https://en.wikipedia.org/wiki/NOT_gate>`__)\n(True when at least one input is false.\n`NAND <https://en.wikipedia.org/wiki/NAND_gate>`__)\nTrue when both inputs are false.\n(`NOR <https://en.wikipedia.org/wiki/NOR_gate>`__)\nTrue when both inputs are equal. Also known as \"exclusive nor\".\n(`XNOR <https://en.wikipedia.org/wiki/XNOR_gate>`__)\n(`XOR <https://en.wikipedia.org/wiki/XOR_gate>`__)\nTrue when both inputs are different. Also known as \"exclusive or\".\nTrue unless the first input is true and the second is false.\n(`IMPLY <https://en.wikipedia.org/wiki/IMPLY_gate>`__)\nTrue when the first input is true and the second is false. Also known as \"\"not imply\".\n(`NIMPLY <https://en.wikipedia.org/wiki/NIMPLY_gate>`__)"
  },
  "FunctionNodeFloatToInt": {
    "label": "Float To Integer Node",
    "description": "The *Float To Integer* node takes a single floating point number input and converts it to\nan integer with a choice of methods.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/math/float_to_integer.rst",
    "inputs": [
      {
        "name": "Float",
        "description": "Standard float value input."
      }
    ],
    "properties": "Rounding Mode\nFor negative numbers, acts as Ceiling."
  },
  "FunctionNodeCompare": {
    "label": "Compare Node",
    "description": "The *Compare* node takes two inputs and does an operation to determine whether they are similar.\nThe node can work on all generic data types, and has modes for vectors that contain more complex\ncomparisons, which can help to reduce the number of necessary nodes, and make a node tree more readable.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/math/compare.rst",
    "inputs": [
      {
        "name": "A, B",
        "description": "Standard value inputs of the selected type."
      },
      {
        "name": "C",
        "description": "Compared against the dot product of two input vectors in when the *Mode* property is set to *Dot Product*."
      },
      {
        "name": "Epsilon",
        "description": "This value is used as a threshold for still considering the two inputs as equal\nfor the Equal and Not Equal operations."
      }
    ],
    "properties": "Mode\nCompare each axis of the input vectors separately, and output true only when the result is true\nfor each axis.\nCompare the length of the two input vectors.\nCompare the average of the elements of the input vectors. This is the same as the implicit\nconversion used when setting the node's data type to *Float*.\nCompare the dot product of the two vectors with the separate *C* input, using the selected operation.\nThe dot product outputs a single value that says how much the two vectors \"agree\".\nCompare the angle between the two vectors with the separate *Angle* input, using the selected operation.\nThe vectors are normalized, so their length does not matter.\nOperation\nTrue when the first input is smaller than second input.\nTrue when the first input is smaller than the second input or equal.\nTrue when the first input is greater than the second input.\nTrue when the first input is greater than the second input or equal.\nTrue when both the difference between the two inputs is smaller than the *Epsilon* input.\nTrue when both the difference between the two inputs is larger than the *Epsilon* input.\nTrue when the first color input is brighter than the second.\nTrue when the first color input is darker than the second."
  },
  "FunctionNodeBitMath": {
    "label": "Bit Math Node",
    "description": "The *Bit Math* node performs bitwise operations on 32-bit integer values.\nIt is useful for low-level data manipulation and logic operations.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/math/bit_math.rst",
    "inputs": [
      {
        "name": "A",
        "description": "The first integer input. Used by all operations."
      },
      {
        "name": "B",
        "description": "The second integer input. Only used by operations that require two inputs (*And*, *Or*, *Exclusive Or*)."
      },
      {
        "name": "Shift",
        "description": "The number of bits to shift or rotate. Used only for *Shift* and *Rotate* operations."
      }
    ],
    "properties": "Operation\nThe bitwise operation to apply:\nNot Inverts the bits of A. Equivalent to `-A - 1` in decimal.\nright."
  },
  "FunctionNodeStringLength": {
    "label": "String Length Node",
    "description": "The *String Length* node outputs the number of characters in the input string.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/string_length.rst",
    "inputs": [
      {
        "name": "String",
        "description": "String value to be evaluated."
      }
    ],
    "outputs": [
      {
        "name": "Length",
        "description": "Integer value representing the length of the input string."
      }
    ]
  },
  "FunctionNodeSliceString": {
    "label": "Slice String Node",
    "description": "The *Slice String* node extracts a string segment from a larger string.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/slice_string.rst",
    "inputs": [
      {
        "name": "String",
        "description": "String value to be sliced."
      },
      {
        "name": "Position",
        "description": "Integer value used to determine the starting point of the new string within the input string.\nThe first letter of the string is at index 0."
      },
      {
        "name": "Length",
        "description": "Integer value used to determine how many characters are extracted from the input string."
      }
    ],
    "outputs": [
      {
        "name": "String",
        "description": "String value of the extracted substring."
      }
    ]
  },
  "FunctionNodeReplaceString": {
    "label": "Replace String Node",
    "description": "The *Replace String* node replaces a string segment with another.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/replace_string.rst",
    "inputs": [
      {
        "name": "String",
        "description": "Standard string input."
      },
      {
        "name": "Find",
        "description": "The substring to find in *String* to be replaced."
      },
      {
        "name": "Replace",
        "description": "A string segment which replaces occurrences of the *Find* substring."
      }
    ],
    "outputs": [
      {
        "name": "String",
        "description": "Standard string output."
      }
    ]
  },
  "FunctionNodeFormatString": {
    "label": "Format String Node",
    "description": "The *Format String* node inserts values into a string using either a Python compatible\nstring format syntax or Blender's format specifier syntax.\nThis node simplifies string construction, allowing values to be combined\nand formatted without converting numbers to strings or using multiple concatenate nodes.\nPython Syntax references:\n- `Python Format String Syntax <https://docs.python.org/3/library/string.html#format-string-syntax>`__\n- `{fmt} Format String Syntax <https://fmt.dev/latest/syntax/>`__",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/format_string.rst",
    "inputs": [
      {
        "name": "Format",
        "description": "A string using either python format style or Blender's format specifier.\nFor example, ``Count: {}`` inserts the first input value in place of the `{}`."
      },
      {
        "name": "Additional input values (Float, Integer, or String) can be managed in the Format Items list in the sidebar.",
        "description": ""
      }
    ]
  },
  "GeometryNodeStringToCurves": {
    "label": "String to Curves Node",
    "description": "The *String to Curves* node converts a string to curve instances. Each unique character used in the string\nis converted to a curve once, and further uses of that character are instances of the same geometry.\nThe name of each instance geometry is the character it represents.\nThis makes processing the output geometry very efficient, because each unique character\nonly has to be processed once. However, it means that the result will be the same\nfor every instance of the same character. To process each character individually,\nthe /modeling/geometry_nodes/instances/realize_instances can be used.\nSocket inspection can be used to see the value\nof the string input used when the node was evaluated, by holding the mouse over the socket.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/string_to_curves.rst",
    "inputs": [
      {
        "name": "String",
        "description": "Standard string input."
      },
      {
        "name": "Size",
        "description": "The size of each character. The values of the other inputs are scaled by this value."
      },
      {
        "name": "Character Spacing",
        "description": "A factor by which the space between each character (kerning) is scaled on the X axis."
      },
      {
        "name": "Word Spacing",
        "description": "A factor by which whitespace between words is scaled on the X axis."
      },
      {
        "name": "Line Spacing",
        "description": "The distance between separate lines in the output. Scaled by the *Size* input."
      },
      {
        "name": "Text Box Width",
        "description": "The maximum width of each line, though individual words will not be wrapped."
      },
      {
        "name": "Text Box Height",
        "description": "The maximum height for all the lines of the text."
      }
    ],
    "outputs": [
      {
        "name": "Curve Instances",
        "description": "Geometry output containing one instance per character."
      },
      {
        "name": "Remainder",
        "description": "The part of the text that did not fit in the box described by the *Text Box Height* and\n*Text Box Width* inputs. Only used in the *Truncate* overflow mode."
      },
      {
        "name": "Line",
        "description": "An attribute field containing the line index of each character\n(on the instance domain)."
      },
      {
        "name": "Pivot Point",
        "description": "Outputs the position described by the *Pivot Point* drop-down in the local space of each instance."
      }
    ],
    "properties": "Font\nFont glyph used to generate the curve.\nOverflow\nControls how the text fits inside the text box.\nWraps the text at the *Text Box Width*.\nScales the text size to fit the *Text Box Width* and *Text Box Height*.\nOnly outputs text characters that fit within the width and height, based on the *Size* input.\nAny part of the string that did not fit is moved to the *Remainder* output.\nAlignment\nControls horizontal alignment of text on each line.\nAlign Y\nControls vertical alignment of the block of text.\nPivot Point\nControls where on each character the output *Pivot Point* is placed.",
    "notes": [
      {
        "type": "tip",
        "text": "Socket inspection can be used to see the value"
      }
    ]
  },
  "FunctionNodeMatchString": {
    "label": "Match String Node",
    "description": "The *Match String* node compares two string values and outputs a Boolean result based on the selected operation.\nIt is useful for conditional logic involving string comparisons, such as matching object names or attribute values.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/match_string.rst",
    "inputs": [
      {
        "name": "String",
        "description": "The input string to be evaluated."
      },
      {
        "name": "Operation",
        "description": "Determines how the input string is compared to the key:\nTrue if the input string begins with the key.\nTrue if the input string ends with the key.\nTrue if the input string contains the key anywhere within it."
      },
      {
        "name": "Key",
        "description": "The target string to compare against."
      }
    ],
    "outputs": [
      {
        "name": "Result",
        "description": "A Boolean value indicating whether the input string matches the key according to the selected operation."
      }
    ]
  },
  "FunctionNodeInputSpecialCharacters": {
    "label": "Special Characters Node",
    "description": "The *Special Characters* node is used to output string characters that can't be typed directly with the keyboard.\nThis node can be used to create a multi-line string for\nthe /modeling/geometry_nodes/utilities/text/string_to_curves,\nwhen combined with the /modeling/geometry_nodes/utilities/text/join_strings\nor the /modeling/geometry_nodes/utilities/text/replace_string.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/special_characters.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Line Break",
        "description": "A new line character (escape character ``\\n``)."
      },
      {
        "name": "Tab",
        "description": "A tab character used to add an indentation in the output."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "This node can be used to create a multi-line string for"
      }
    ]
  },
  "FunctionNodeStringToValue": {
    "label": "String to Value Node",
    "description": "The *String to Value* node converts a text string into a numerical value.\nThis is useful for parsing numbers from text input, file data, or dynamically generated strings.\nThe node reads characters from the beginning of the string until a valid number is parsed.\nIf parsing is unsuccessful, the node outputs a floating-point value of 0.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/string_to_value.rst",
    "inputs": [
      {
        "name": "String",
        "description": "The input text string to be converted into a numerical value."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "The resulting numerical value after conversion."
      },
      {
        "name": "Length",
        "description": "The number of characters successfully parsed as part of the number.\nThis indicates where the numeric portion of the string ends, allowing further substring operations."
      }
    ],
    "properties": "Data Type\nThe type of numerical value to convert to:"
  },
  "FunctionNodeFindInString": {
    "label": "Find in String Node",
    "description": "The *Find in String* node finds the number of times a substring occurs in a string, and the position of the start of\nthe first match.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/find_in_string.rst",
    "inputs": [
      {
        "name": "String",
        "description": "The input string in which the search will be conducted."
      },
      {
        "name": "Search",
        "description": "The substring that will be searched for within the input string."
      }
    ],
    "outputs": [
      {
        "name": "First Found",
        "description": "The start position of the first occurrence of the substring within the input string."
      },
      {
        "name": "Count",
        "description": "The total number of occurrences of the substring within the input string."
      }
    ]
  },
  "GeometryNodeStringJoin": {
    "label": "Join Strings Node",
    "description": "The *Join Strings* node combines any number of input strings into the output string.\nThe order of the result depends on the vertical ordering of the inputs in the multi-input socket.\nThis node can be used to create a multi-line string for\nthe /modeling/geometry_nodes/utilities/text/string_to_curves,\nwhen combined with the line break output from\nthe /modeling/geometry_nodes/utilities/text/special_characters.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/join_strings.rst",
    "inputs": [
      {
        "name": "Delimiter",
        "description": "String value to place between each concatenated string."
      },
      {
        "name": "Strings",
        "description": "Multiple string values to be combined in connection order."
      }
    ],
    "outputs": [
      {
        "name": "String",
        "description": "String result of the concatenation."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "This node can be used to create a multi-line string for"
      }
    ]
  },
  "FunctionNodeValueToString": {
    "label": "Value to String Node",
    "description": "The *Value to String* node generates string representation of the input value.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/text/value_to_string.rst",
    "inputs": [
      {
        "name": "Value",
        "description": "Floating-point value to be converted."
      },
      {
        "name": "Decimals Float Data Type",
        "description": "Integer value used to determine the precision of the output value."
      }
    ],
    "outputs": [
      {
        "name": "String",
        "description": "String value representation of the input."
      }
    ],
    "properties": "Data Type\nThe type of numerical value to convert to a string."
  },
  "FunctionNodeAxisAngleToRotation": {
    "label": "Axis Angle to Rotation Node",
    "description": "The *Axis Angle to Rotation* node converts a axis angle rotation to a standard rotation\nvalue.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/axis_angle_to_rotation.rst",
    "inputs": [
      {
        "name": "Axis",
        "description": "Unit vector representing the axis to rotate around."
      },
      {
        "name": "Angle",
        "description": "The rotation angle around the axis."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "Standard rotation value."
      }
    ]
  },
  "FunctionNodeQuaternionToRotation": {
    "label": "Quaternion to Rotation Node",
    "description": "The *Quaternion to Rotation* node converts a quaternion rotation to a standard rotation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/quaternion_to_rotation.rst",
    "inputs": [
      {
        "name": "W",
        "description": "The W value of the quaternion."
      },
      {
        "name": "X",
        "description": "The X value of the quaternion."
      },
      {
        "name": "Y",
        "description": "The Y value of the quaternion."
      },
      {
        "name": "Z",
        "description": "The Z value of the quaternion."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "Standard rotation value."
      }
    ]
  },
  "FunctionNodeInvertRotation": {
    "label": "Invert Rotation Node",
    "description": "The *Invert Rotation* node inverts a rotation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/invert_rotation.rst",
    "inputs": [
      {
        "name": "Rotation",
        "description": "Standard rotation value."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "The inverted rotation."
      }
    ]
  },
  "FunctionNodeRotationToEuler": {
    "label": "Rotation to Euler Node",
    "description": "The *Rotation to Euler* node converts a standard rotation socket value to an Euler rotation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/rotation_to_euler.rst",
    "inputs": [
      {
        "name": "Rotation",
        "description": "Standard rotation socket value."
      }
    ],
    "outputs": [
      {
        "name": "Euler",
        "description": "The Euler rotation."
      }
    ]
  },
  "FunctionNodeRotateVector": {
    "label": "Rotate Vector Node",
    "description": "The *Rotate Vector* node rotates a vector by a given rotation value.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/rotate_vector.rst",
    "inputs": [
      {
        "name": "Vector",
        "description": "The vector to rotate."
      },
      {
        "name": "Rotation",
        "description": "Standard rotation value."
      }
    ],
    "outputs": [
      {
        "name": "Vector",
        "description": "The rotated vector."
      }
    ]
  },
  "FunctionNodeRotateRotation": {
    "label": "Rotate Rotation Node",
    "description": "The *Rotate Rotation* node applies an additional rotation to a given one.\nTo rotate an Euler Rotation, first use the\n/modeling/geometry_nodes/utilities/rotation/euler_to_rotation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/rotate_rotation.rst",
    "inputs": [
      {
        "name": "Rotation",
        "description": "The starting rotation."
      },
      {
        "name": "Rotate By",
        "description": "The additional rotation."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "The resulting rotation."
      }
    ],
    "properties": "Space\nGlobal Rotate in Global Space.\nLocal Rotate in Local Space."
  },
  "FunctionNodeAxesToRotation": {
    "label": "Axes to Rotation Node",
    "description": "Creates a rotation based on two axis directions.\nIn many cases, these directions are a normal and tangent on a mesh or curve.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/axes_to_rotation.rst",
    "inputs": [
      {
        "name": "Primary Axis",
        "description": "The desired direction of the primary axis."
      },
      {
        "name": "Secondary Axis",
        "description": "The desired direction of the secondary axis. Ideally, this is orthogonal to the primary direction."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "The rotation that results in the given axes being aligned to the given directions."
      }
    ],
    "properties": "Primary Axis\nThe axis (X, Y or Z) that should be aligned exactly to the primary direction.\nSecondary Axis\nThe axis that should be aligned as closely as possible to the secondary direction.",
    "notes": [
      {
        "type": "tip",
        "text": "In many cases, these directions are a normal and tangent on a mesh or curve."
      }
    ]
  },
  "FunctionNodeEulerToRotation": {
    "label": "Euler to Rotation Node",
    "description": "The *Euler to Rotation* node creates a rotation value from an Euler rotation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/euler_to_rotation.rst",
    "inputs": [
      {
        "name": "Euler",
        "description": "The Euler rotation."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "Standard rotation value."
      }
    ]
  },
  "FunctionNodeRotationToQuaternion": {
    "label": "Rotation to Quaternion Node",
    "description": "The *Rotation to Quaternion* node converts a standard rotation value to a\nquaternion rotation.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/rotation_to_quaternion.rst",
    "inputs": [
      {
        "name": "Rotation",
        "description": "Standard rotation value."
      }
    ],
    "outputs": [
      {
        "name": "W",
        "description": "The W value of the quaternion."
      },
      {
        "name": "X",
        "description": "The X value of the quaternion."
      },
      {
        "name": "Y",
        "description": "The Y value of the quaternion."
      },
      {
        "name": "Z",
        "description": "The Z value of the quaternion."
      }
    ]
  },
  "FunctionNodeAlignRotationToVector": {
    "label": "Align Rotation to Vector Node",
    "description": "The *Align Rotation to Vector* node rotates an Euler rotation into the given direction.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/rotation/align_rotation_to_vector.rst",
    "inputs": [
      {
        "name": "Rotation",
        "description": "The Euler rotation to align.\nThis input has to be a rotation input. Be careful not to connect a direction vector\nlike the normal."
      },
      {
        "name": "Factor",
        "description": "Determines how much the points are rotated towards the vector.\nZero effectively disables the node and one means that the points are aligned with the vector perfectly."
      },
      {
        "name": "Vector",
        "description": "The direction vector that points should be rotated to.\nThe vector is in the local space of the object that is being modified.\nWhen it is all zeros for a point, it is not rotated at all."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "The rotated Euler rotation."
      }
    ],
    "properties": "Axis\nLocal axis of the object that is to be rotated towards the vector input.\nPivot\nThe local axis to rotate around.\nThe best rotation angle is computed automatically.\nThis minimizes the angle of rotation.\nRotate around a specific local axis."
  },
  "FunctionNodeTransformPoint": {
    "label": "Transform Point Node",
    "description": "The *Transform Point* node applies a Transformation Matrix to a position vector.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/transform_point.rst",
    "inputs": [
      {
        "name": "Vector",
        "description": "The position of a point to transform."
      },
      {
        "name": "Transformation",
        "description": "The transformation matrix."
      }
    ],
    "outputs": [
      {
        "name": "Vector",
        "description": "The transformed point."
      }
    ]
  },
  "FunctionNodeProjectPoint": {
    "label": "Project Point Node",
    "description": "Applies a projection matrix to a point. Specifically, this node turns the given\nEuclidean vector (X, Y, Z) into the homogeneous vector (X, Y, Z, 1),\nmultiplies the given projection matrix by it,\nand turns the resulting homogeneous vector back into a Euclidean one by dividing\nit by the absolute value of its W component. This last step is also known as\nperspective division.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/project_point.rst",
    "inputs": [
      {
        "name": "Vector",
        "description": "The position vector to project."
      },
      {
        "name": "Transformation",
        "description": "The projection matrix."
      }
    ],
    "outputs": [
      {
        "name": "Vector",
        "description": "The projected position vector."
      }
    ]
  },
  "FunctionNodeMatrixMultiply": {
    "label": "Multiply Matrices Node",
    "description": "The *Multiply Matrices* node performs a\n`matrix multiplication <https://en.wikipedia.org/wiki/Matrix_multiplication>`__\non two input matrices.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/multiply_matrices.rst",
    "inputs": [
      {
        "name": "Matrix",
        "description": "The first multiplication."
      },
      {
        "name": "Matrix",
        "description": "The second multiplication."
      }
    ],
    "outputs": [
      {
        "name": "Matrix",
        "description": "The resulting matrix multiplication."
      }
    ]
  },
  "FunctionNodeSeparateTransform": {
    "label": "Separate Transform Node",
    "description": "The *Separate Transform* node separates a Transformation Matrix\ninto a translation vector, a rotation vector, and a scale vector.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/separate_transform.rst",
    "inputs": [
      {
        "name": "Transform",
        "description": "The transformation matrix to separate."
      }
    ],
    "outputs": [
      {
        "name": "Translation",
        "description": "The translation vector."
      },
      {
        "name": "Rotation",
        "description": "The rotation vector."
      },
      {
        "name": "Scale",
        "description": "The scale vector."
      }
    ]
  },
  "FunctionNodeInvertMatrix": {
    "label": "Invert Matrix Node",
    "description": "Returns the `inverse <https://mathworld.wolfram.com/MatrixInverse.html>`__ of the given matrix.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/invert_matrix.rst",
    "inputs": [
      {
        "name": "Matrix",
        "description": "The matrix to invert."
      }
    ],
    "outputs": [
      {
        "name": "Matrix",
        "description": "The inverted matrix."
      },
      {
        "name": "Invertible",
        "description": "Returns whether the matrix could be inverted.\nThis can be false when a transformation matrix has a scale of zero, for example.\nSee `Invertible matrix <https://en.wikipedia.org/wiki/Invertible_matrix>`__ for more information.\nWhen a matrix is not invertible, the `identity matrix <https://en.wikipedia.org/wiki/Identity_matrix>`__\nis returned."
      }
    ]
  },
  "FunctionNodeTransformDirection": {
    "label": "Transform Direction Node",
    "description": "The *Transform Direction* node multiplies a Transformation Matrix by a vector.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/transform_direction.rst",
    "inputs": [
      {
        "name": "Direction",
        "description": "The vector."
      },
      {
        "name": "Transformation",
        "description": "The transformation matrix."
      }
    ],
    "outputs": [
      {
        "name": "Direction",
        "description": "The vector."
      }
    ]
  },
  "FunctionNodeMatrixDeterminant": {
    "label": "Matrix SVD Node",
    "description": "The *Matrix SVD* node computes the 3D `singular value decomposition <https://en.wikipedia.org/wiki/Singular_value_decomposition>`__\nof the input matrix. The SVD describes the matrix in terms of a left and a right transformation ``U`` and ``V`` with a diagonal\nscaling matrix ```S`` inbetween.\n``M = U * S * transpose(V)``\nOnly the 3x3 part of the input matrix ``M`` is used, the translation part (4th column vector) is not used. The matrix does\nnot have to be a pure (affine) transformation, any input matrix can be decomposed.\nThe output matrices ``U`` and ``V`` consist only of rotations and reflections (+1 or -1 scaling). If the input matrix ``M``\nhas a positive determinant then ``U`` and ``V`` are pure rotations. The scaling matrix ``S`` is described only by the diagonal vector.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/matrix_svd.rst",
    "inputs": [
      {
        "name": "Matrix",
        "description": "The matrix to decompose."
      }
    ],
    "outputs": [
      {
        "name": "U",
        "description": "Left-hand transform."
      },
      {
        "name": "S",
        "description": "Singular values."
      },
      {
        "name": "V",
        "description": "Right-hand transform."
      }
    ]
  },
  "FunctionNodeSeparateMatrix": {
    "label": "Separate Matrix Node",
    "description": "The *Separate Matrix* node splits a 4x4 matrix into its individual values.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/separate_matrix.rst",
    "inputs": [
      {
        "name": "Matrix",
        "description": "The matrix to split into individual values."
      }
    ],
    "outputs": [
      {
        "name": "The outputs of this node are split into panels for each column of the matrix.",
        "description": ""
      },
      {
        "name": "Each panel, has four value outputs for the four rows of the matrix.",
        "description": ""
      }
    ]
  },
  "FunctionNodeTransposeMatrix": {
    "label": "Transpose Matrix Node",
    "description": "The *Transpose Matrix* node flips a matrix over its diagonal.\n`Transpose <https://en.wikipedia.org/wiki/Transpose>`__ on Wikipedia.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/transpose_matrix.rst",
    "inputs": [
      {
        "name": "Matrix",
        "description": "The matrix to be transposed."
      }
    ],
    "outputs": [
      {
        "name": "Matrix",
        "description": "The transposed matrix."
      }
    ]
  },
  "FunctionNodeCombineMatrix": {
    "label": "Combine Matrix Node",
    "description": "The *Combine Matrix* node constructs a 4x4 matrix from its individual values.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/combine_matrix.rst",
    "inputs": [
      {
        "name": "The inputs of this node are split into panels for each column of the matrix.",
        "description": ""
      },
      {
        "name": "Each panel, has four value inputs for the four rows of the matrix.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Matrix",
        "description": "The constructed matrix."
      }
    ]
  },
  "FunctionNodeCombineTransform": {
    "label": "Combine Transform Node",
    "description": "The *Combine Transform* node combines a translation vector,\na rotation vector, and a scale vector into a Transformation Matrix.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/matrix/combine_transform.rst",
    "inputs": [
      {
        "name": "Translation",
        "description": "The translation vector."
      },
      {
        "name": "Rotation",
        "description": "The rotation vector."
      },
      {
        "name": "Scale",
        "description": "The scale vector."
      }
    ],
    "outputs": [
      {
        "name": "Transform",
        "description": "The combined transformation matrix."
      }
    ]
  },
  "FunctionNodeRotateEuler": {
    "label": "Rotate Euler Node",
    "description": "The *Rotate Euler* node rotates an Euler rotation.\nThis node is deprecated, use the /modeling/geometry_nodes/utilities/rotation/rotate_rotation instead.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/deprecated/rotate_euler.rst",
    "inputs": [
      {
        "name": "Rotation",
        "description": "The Euler rotation to rotate."
      },
      {
        "name": "Rotate By",
        "description": "Specifies how much an Euler rotation is rotated. This input is only available\nwhen the rotation type is set to *Euler*."
      },
      {
        "name": "Axis",
        "description": "The axis to rotate around. This input is only available when the rotation type is set to *Axis Angle*."
      },
      {
        "name": "Angle",
        "description": "The angle to rotate by around the specified axis. This input is only available\nwhen the rotation type is set to *Axis Angle*."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "The rotated Euler rotation."
      }
    ],
    "properties": "Rotation Type\nSpace"
  },
  "FunctionNodeAlignEulerToVector": {
    "label": "Align Euler to Vector Node",
    "description": "The *Align Euler to Vector* node rotates an Euler rotation into the given direction.\nThis node is deprecated, use the /modeling/geometry_nodes/utilities/rotation/align_rotation_to_vector\ninstead.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/utilities/deprecated/align_euler_to_vector.rst",
    "inputs": [
      {
        "name": "Rotation",
        "description": "The Euler rotation to align.\nThis input has to be a rotation input. Be careful not to connect a direction vector\nlike the normal."
      },
      {
        "name": "Factor",
        "description": "Determines how much the points are rotated towards the vector.\nZero effectively disables the node and one means that the points are aligned with the vector perfectly."
      },
      {
        "name": "Vector",
        "description": "The direction vector that points should be rotated to.\nThe vector is in the local space of the object that is being modified.\nWhen it is all zeros for a point, it is not rotated at all."
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "The rotated Euler rotation."
      }
    ],
    "properties": "Axis\nLocal axis of the object that is to be rotated towards the vector input.\nPivot\nThe local axis to rotate around.\nThe best rotation angle is computed automatically.\nThis minimizes the angle of rotation.\nRotate around a specific local axis."
  },
  "GeometryNodeImageTexture": {
    "label": "Image Texture Node",
    "description": "Unlike the other texture nodes, this node operates differently\nin geometry nodes compared to the equivalent shader node.\nWhen not connected the Vector input has an implicit ``position`` attribute value.\nThe *Image Texture* node is used to add an image file as a texture.\nThe image data is sampled with the input Vector and outputs a Color and Alpha value.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/texture/image.rst",
    "inputs": [
      {
        "name": "Image",
        "description": "The image socket can be used to connect to the Group Input node.\nIf this is not connected the image can be opened or selected from the node."
      },
      {
        "name": "Vector",
        "description": "Texture coordinate for texture look-up. If this socket is left unconnected,\nthe Position attribute is used."
      },
      {
        "name": "Frame",
        "description": "If the Image supports animation, the frame can be set here.\nThis can be keyframed so that the image changes between frames."
      }
    ],
    "outputs": [
      {
        "name": "Color",
        "description": "RGBA color from the image."
      },
      {
        "name": "Alpha",
        "description": "Alpha channel from image."
      }
    ],
    "properties": "Interpolation\nMethod to scale images up or down for sampling.\nExtension\nExtension defines how the image is extrapolated past the original bounds:",
    "notes": [
      {
        "type": "note",
        "text": "Unlike the other texture nodes, this node operates differently"
      }
    ]
  },
  "GeometryNodeRealizeInstances": {
    "label": "Realize Instances Node",
    "description": "The *Realize Instances* node makes any instances (efficient duplicates of the same geometry)\ninto real geometry data. This makes it possible to affect each instance individually,\nwhereas without this node, the exact same changes are applied to every instance of\nthe same geometry. However, performance can become much worse when the input\ncontains many instances of complex geometry, which is a fundamental limitation\nwhen procedurally processing geometry.\nIf the input contains multiple volume instances, only the first volume component is moved to the output.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/realize_instances.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Which top-level instances to realize."
      },
      {
        "name": "Realize All",
        "description": "Realize all levels of nested instances for each top-level instances\n(overrides the value of the *Depth* input)."
      },
      {
        "name": "Depth",
        "description": "Number of levels of nested instances to realize for each top-level instance."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "If the input contains multiple volume instances, only the first volume component is moved to the output."
      },
      {
        "type": "note",
        "text": "- The ``id`` attribute receives special handling to prevent duplicate values. ``id`` values or indices"
      }
    ]
  },
  "GeometryNodeInstancesToPoints": {
    "label": "Instances to Points Node",
    "description": "The *Instances to Points* node generates points at the origins of top-level instances.\nAttributes on the instance domain are moved to the point cloud points.\nTop-level instances are those that are owned by the node's input geometry.\nInstances owned by other instances, i.e. nested instances, are not considered\nby this node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/instances_to_points.rst",
    "inputs": [
      {
        "name": "Instances",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "The instances used to generate points. True values mean a point is created for the instance,\nfalse values mean the instance is skipped."
      },
      {
        "name": "Position",
        "description": "Overrides the default position of generated point."
      },
      {
        "name": "Radius",
        "description": "Controls the radius of the result points."
      }
    ],
    "outputs": [
      {
        "name": "Points",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Top-level instances are those that are owned by the node's input geometry."
      }
    ]
  },
  "GeometryNodeInputInstanceBounds": {
    "label": "Instance Bounds Node",
    "description": "The *Instance Bounds* node outputs the axis-aligned bounding box of each instance in the input geometry.\nThis can be used to determine the spatial extent of instances,\nfor example, to position or scale objects based on their size.\nOnly top-level instances are considered; the bounds do not include nested instances inside the instance geometry.\nThis avoids the performance cost of realizing nested instances for accurate bounds.\nSee geometry-nodes_nested-instancing for more information.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/instance_bounds.rst",
    "inputs": [
      {
        "name": "Use Radius",
        "description": "For curves, point clouds, and Grease Pencil geometries,\ntake the radius attribute into account when computing the bounds."
      }
    ],
    "outputs": [
      {
        "name": "Min",
        "description": "The minimum corner of the bounding box for each instance, in local space."
      },
      {
        "name": "Max",
        "description": "The maximum corner of the bounding box for each instance, in local space."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Only top-level instances are considered; the bounds do not include nested instances inside the instance geometry."
      }
    ]
  },
  "GeometryNodeScaleInstances": {
    "label": "Scale Instances Node",
    "description": "The *Scale Instances* node scales geometry instances in local or global space.\nThe /modeling/geometry_nodes/instances page contains more information about geometry instances.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/scale_instances.rst",
    "inputs": [
      {
        "name": "Instances",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field used to determine if an instance will be scaled."
      },
      {
        "name": "Scale",
        "description": "The scale factor to apply to the instance's transform on each axis."
      },
      {
        "name": "Center",
        "description": "The position from which the instance origins are scaled. Each instance will move away from this location.\nWhen the *Local Space* input is enabled, this location is relative to the initial transform\nof each instance."
      },
      {
        "name": "Local Space",
        "description": "If enabled, the instances are scaled in local space. In other words,\nthey are scaled in the directions the described by the initial transform of each instance.\nWhen the input is disabled, the *Center* and *Scale* inputs are specified in\nthe local space of the modifier object."
      }
    ],
    "outputs": [
      {
        "name": "Instances",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeInputInstanceRotation": {
    "label": "Instance Rotation Node",
    "description": "The *Instance Rotation* outputs the XYZ Euler rotation of each top-level instance in the\nlocal space of the modifier object.\nThe /modeling/geometry_nodes/instances page contains more information about geometry instances.\nThough rotations are often displayed in units of degrees in the spreadsheet or node editor,\nthey are stored internally in radians, so this node outputs radians.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/instance_rotation.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Rotation",
        "description": "Vector that indicates the rotation of each top-level instance in radians."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Though rotations are often displayed in units of degrees in the spreadsheet or node editor,"
      }
    ]
  },
  "GeometryNodeSetInstanceTransform": {
    "label": "Set Instance Transform Node",
    "description": "The *Set Instance Transform* node Transforms geometry instances\nusing a Transformation Matrix.\nThe /modeling/geometry_nodes/instances page contains more information about geometry instances.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/set_instance_transform.rst",
    "inputs": [
      {
        "name": "Instances",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field used to determine if an instance will be rotated."
      },
      {
        "name": "Transform",
        "description": "The transformation matrix to translate, rotate, and scale individual instances."
      }
    ],
    "outputs": [
      {
        "name": "Instances",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeInstanceTransform": {
    "label": "Instance Transform Node",
    "description": "The *Instance Transform* outputs the Transformation Matrix of each top-level instance in the\nlocal space of the modifier object.\nThe /modeling/geometry_nodes/instances page contains more information about geometry instances.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/instance_transform.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Transformation",
        "description": "Matrix that indicates the Transformation of each top-level instance."
      }
    ]
  },
  "GeometryNodeRotateInstances": {
    "label": "Rotate Instances Node",
    "description": "The *Rotate Instances* node rotates geometry instances in local or global space.\nThe /modeling/geometry_nodes/instances page contains more information about geometry instances.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/rotate_instances.rst",
    "inputs": [
      {
        "name": "Instances",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field used to determine if an instance will be rotated."
      },
      {
        "name": "Rotation",
        "description": "The Euler rotation to rotate the instances by."
      },
      {
        "name": "Pivot Point",
        "description": "The position around which each instance is rotated. If the *Local Space* input is true,\nthe location is relative to the initial transform of the instance."
      },
      {
        "name": "Local Space",
        "description": "If enabled, the instances are rotated in local space. In other words,\nthey are rotated around the axes described by the initial transform of each instance.\nWhen the input is disabled, the pivot point and rotation are specified in\nthe local space of the modifier object."
      }
    ],
    "outputs": [
      {
        "name": "Instances",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeTranslateInstances": {
    "label": "Translate Instances Node",
    "description": "The *Translate Instances* node moves top-level geometry instances in local or global space.\nThe /modeling/geometry_nodes/instances page contains more information about geometry instances.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/translate_instances.rst",
    "inputs": [
      {
        "name": "Instances",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field used to determine if an instance will be translated."
      },
      {
        "name": "Translation",
        "description": "The vector to translate the instances by."
      },
      {
        "name": "Local Space",
        "description": "If enabled, the instances are translated relative to their initial rotation.\nOtherwise they are translated in the local space of the modifier object."
      }
    ],
    "outputs": [
      {
        "name": "Instances",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeInstanceOnPoints": {
    "label": "Instance on Points Node",
    "description": "The *Instance on Points* node adds a reference to a geometry to each of the points present\nin the input geometry. Instances are a fast way to add the same geometry to a scene many times\nwithout duplicating the underlying data. The node works on any geometry type\nwith a *Point* domain, including meshes, point clouds, and curve control points.\nAny attributes on the points from the *Geometry* input will be available on the instance\ndomain of the generated instances.\nThe bpy.ops.object.duplicates_make_real operator can be used to create objects\nfrom instances generated with this node.\nTo instance object types that do not contain geometry, like a light object, the\n/modeling/geometry_nodes/input/scene/object_info can be used. Other objects like\nMetaball objects are not supported for instancing.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/instance_on_points.rst",
    "inputs": [
      {
        "name": "Points",
        "description": "Standard geometry input. The position of the points of this geometry affect the transforms of\neach instance output.\nIf the input geometry contains instances, the node will create more instances on\nthe points inside the instances, creating nested instancing.\nIn this case, each new instance will have the transform created by the node from the *Rotation*\nand *Scale* inputs, but it will *also* be transformed based on the parent instances."
      },
      {
        "name": "Selection",
        "description": "Whether to instance on each point. True values mean an instance will be generated on the point,\nfalse values mean the point will be skipped."
      },
      {
        "name": "Instance",
        "description": "The geometry to instance on each selected point. This can contain real geometry, or multiple instances,\nwhich can be useful when combined with the *Pick Instance* option."
      },
      {
        "name": "Pick Instances",
        "description": "If enabled, instead of adding the entire geometry from the *Instance* input on every point,\nchoose an instance from the instance list of the geometry based on the *Instance Index* input.\nThis option is intended to be used with the /modeling/geometry_nodes/input/scene/collection_info."
      },
      {
        "name": "Instance Index",
        "description": "The selection of index for every selected point, only used when *Pick Instances* is true.\nBy default the point ID is used,\nor the index if that doesn't exist.\nNegative values or values that are too large are wrapped around to the other end of\nthe instance list."
      },
      {
        "name": "Rotation",
        "description": "The Euler rotation for every instance. This can use the rotation output of nodes like\nDistribute Points on Faces\nand Curve to Points. An Euler rotation\ncan also be created from a direction vector like the normal\nwith the /modeling/geometry_nodes/utilities/rotation/align_rotation_to_vector."
      },
      {
        "name": "Scale",
        "description": "The size of each generated instance."
      }
    ],
    "outputs": [
      {
        "name": "Instances",
        "description": "Standard geometry output. If the ``id`` attribute exists on the input geometry,\nit will be copied to the result instances."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "The bpy.ops.object.duplicates_make_real operator can be used to create objects"
      },
      {
        "type": "note",
        "text": "To instance object types that do not contain geometry, like a light object, the"
      },
      {
        "type": "note",
        "text": "If the input geometry contains instances, the node will create more instances on"
      }
    ]
  },
  "GeometryNodeInputInstanceScale": {
    "label": "Instance Scale Node",
    "description": "The *Instance Scale* outputs the size of top-level instances on each axis in the\nlocal space of the modifier object.\nThe /modeling/geometry_nodes/instances page contains more information about geometry instances.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/instances/instance_scale.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Scale",
        "description": "Vector that indicates the scale of each top-level instance."
      }
    ]
  },
  "GeometryNodeGeometryToInstance": {
    "label": "Geometry to Instance Node",
    "description": "The *Geometry to Instance* node turns every connected input geometry into an instance.\nVisually, the node has a similar result as the /modeling/geometry_nodes/geometry/join_geometry,\nbut it outputs the result as separate instances instead. The geometry data itself isn't actually\njoined.\nThe node can be used in combination with the *Pick Instances* option in the\n/modeling/geometry_nodes/instances/instance_on_points, as a way to pick\nbetween geometry generated in the node tree (as opposed to picking from separate\ninstances from the /modeling/geometry_nodes/input/scene/collection_info, for example).\nThis node can be much faster than the join geometry node when the inputs are large geometries.\nThis is because the join geometry node must actually create a larger mesh, or a larger curve.\nEven though the operation is simple, just creating a large mesh can have a significant cost.\nThis node can be better, because instead of merging large geometries, it just groups them\ntogether as instances.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/geometry_to_instance.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Geometry that will be joined. Multiple inputs are allowed.\nWhen the node is muted, only the first link will be passed through."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "This node can be much faster than the join geometry node when the inputs are large geometries."
      }
    ]
  },
  "GeometryNodeJoinGeometry": {
    "label": "Join Geometry Node",
    "description": "The *Join Geometry* node merges separately generated geometries into a single one.\nIf the geometry inputs contain different types of data, the output will also contain different data types.\nThe node cannot handle the case when more than one geometry input has a volume component.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/join_geometry.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Geometry that will be joined. Multiple inputs are allowed.\nWhen the node is muted, only the first link will be passed through."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "The node cannot handle the case when more than one geometry input has a volume component."
      },
      {
        "type": "note",
        "text": "Vertex groups are preserved when realizing instances or joining geometries."
      }
    ]
  },
  "GeometryNodeSetPosition": {
    "label": "Set Position Node",
    "description": "The *Set Position* node controls the location of each point, the same way as controlling\nthe ``position`` attribute.\nIf the input geometry contains instances, this node will affect the location of the origin of each instance.\nThe input node for this data is the /modeling/geometry_nodes/geometry/read/position.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/write/set_position.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Whether or not to change the position of each point or instance.\nTrue values mean the position will be changed, false values mean it will remain the same."
      },
      {
        "name": "Position",
        "description": "The new position for selected elements. By default, this is the same as\nif the /modeling/geometry_nodes/geometry/read/position was connected,\nmeaning the node will do nothing."
      },
      {
        "name": "Offset",
        "description": "An optional translation for each point. This is evaluated at the same time as the *Position* input,\nmeaning that fields evaluated for it will not reflect the changed position."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeToolSetSelection": {
    "label": "Set Selection Node",
    "description": "The *Set Selection* node controls which geometry is selected.\nThe input node for this data is the /modeling/geometry_nodes/geometry/read/selection.\nThis node can only be used in the Tool context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/write/set_selection.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field for specifying which elements should be selected in the output geometry.\nElements for which this field evaluates to false are implicitly de-selected."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Domain\nWhich domain to set the selection on.",
    "notes": [
      {
        "type": "note",
        "text": "This node can only be used in the Tool context."
      }
    ]
  },
  "GeometryNodeSetGeometryName": {
    "label": "Set Geometry Name Node",
    "description": "The *Set Geometry Name* node stores a custom name on the geometry, overriding the name which\nmight come from the /modeling/geometry_nodes/input/scene/object_info or a\n/modeling/geometry_nodes/grease_pencil/operations/grease_pencil_to_curves.\nThe name is displayed in the spreadsheet and can helpful for debugging purposes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/write/set_geometry_name.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Name",
        "description": "The new name for the geometry."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeSetID": {
    "label": "Set ID Node",
    "description": "The *Set ID* node fills the ``id`` attribute on the input geometry. If the attribute does not\nexist yet, it will be created with a default value of zero. The ID is also created by\nthe /modeling/geometry_nodes/point/distribute_points_on_faces, and it is used in\nthe /modeling/geometry_nodes/utilities/random_value and other nodes if it exists.\nThe input node for this data is the /modeling/geometry_nodes/geometry/read/id.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/write/set_id.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Whether or not to change the value on each point or instance.\nTrue values mean the value will be changed, false values mean the value will remain the same."
      },
      {
        "name": "ID",
        "description": "The value for each element. By default, this input uses\nthe index, which is useful\nwhen stable IDs are desired when deleting a dynamic number of instances."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeInputIndex": {
    "label": "Index Node",
    "description": "The *Index* node gives an integer value indicating the position of each element in the list,\nstarting at zero. This depends on the internal order of the data in the geometry, which is not\nnecessarily visible in the 3D Viewport. However, the index value is visible in the left-most column\nin the Spreadsheet Editor.\nIndices in geometry data are often defined by the internals of complex algorithms that create it.\nIf no inputs change, indices will be the same when the same node tree is executed multiple times.\nHowever, they may not be predictable when inputs to nodes that generate geometry or change its\ntopology are adjusted. Additionally, updates to algorithms in newer versions of Blender may\nchange the order of generated elements.\nTo avoid relying on consistent indices, it is recommended to calculate them locally,\nor to avoid operations that change topology when they must be consistent over time.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/read/input_index.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Index",
        "description": "Integer value which enumerates each point on the geometry."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Indices in geometry data are often defined by the internals of complex algorithms that create it."
      }
    ]
  },
  "GeometryNodeToolSelection": {
    "label": "Selection Node",
    "description": "The *Selection* node outputs true for geometry that is selected, and false elsewhere.\nThe corresponding data flow node is the /modeling/geometry_nodes/geometry/write/set_selection.\nThis node can only be used in the Tool context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/read/selection.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Selection",
        "description": "Boolean field set to true for geometry that is selected in edit mode."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "This node can only be used in the Tool context."
      }
    ]
  },
  "GeometryNodeInputPosition": {
    "label": "Position Node",
    "description": "The *Position* node outputs a vector of each point of the geometry the node is connected to.\nThe node can work on geometry domains besides points. In that case, the position data will be\nautomatically interpolated to the new domain. For example, when used as part of the input to\nthe /modeling/geometry_nodes/mesh/operations/split_edges, the position for each edge\nwill be the average position of the edge's two vertices.\nFor instances themselves, the output is the origin of each instance. However, if the node is for\na geometry node that adjusts data inside instances, the position output of this node will be\nin the local space of each instance. See the geometry-nodes_instance-processing page\nfor more details.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/read/position.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Position",
        "description": "Vector that indicates the location of each element of the geometry."
      }
    ]
  },
  "GeometryNodeInputRadius": {
    "label": "Radius Node",
    "description": "The *Radius* node outputs the radius value at each point on the evaluated geometry.\nFor curves, this value is used for things like determining the size of the mesh created in\nthe Curve to Mesh node.\nFor point clouds, the value is used for the display size of the point in the viewport.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/read/radius.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Radius",
        "description": "Float value indicating radius at each point on the geometry."
      }
    ]
  },
  "GeometryNodeInputNormal": {
    "label": "Normal Node",
    "description": "The *Normal* node returns a vector for each evaluated point indicating the\nnormal direction. The output can depend\non the attribute domain used in the node evaluating the field, but the output\nis always a normalized `unit vector <https://en.wikipedia.org/wiki/Unit_vector>`__.\nOn the face domain, the normal is the \"up\" direction of the face.\nFor mesh vertices, the normal is an average of the surrounding face normals.\nIf the vertex does not have any connected faces, the output is simply the normalized position\nof that vertex.\nThe normal output for each edge is the average of the edge's two vertex normals.\nThe output for each face corner is the same as the face normal of the corresponding face.\nThe output of this node when used for curve geometry is the evaluated normal of the curve,\nwhich depends on the twist method. The normal vector is always perpendicular to the direction\nof the curve's path at every point.\nFor NURBS and B\u00e9zier spline curves, keep in mind that the value retrieved from this node is\nthe value at every control point, which may not correspond to the visible *evaluated* points.\nFor NURBS splines the difference may be even more pronounced and the result may not be as expected.\nA /modeling/geometry_nodes/curve/operations/resample_curve can be used to create a poly spline,\nwhere there is a control point for every evaluated point.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/read/normal.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Normal",
        "description": "Vector indicating the normal of each geometry element."
      },
      {
        "name": "True Normal",
        "description": "For meshes, outputs normals without custom normals attributes taken into\naccount."
      }
    ],
    "notes": [
      {
        "type": "warning",
        "text": "For NURBS and B\u00e9zier spline curves, keep in mind that the value retrieved from this node is"
      }
    ]
  },
  "GeometryNodeToolActiveElement": {
    "label": "Active Element Node",
    "description": "The *Active Element* node outputs the index of the Active point, edge, face, or layer.\nThis node can only be used in the Tool context.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/read/active_element.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Index",
        "description": "Index of the active element in the specified domain."
      },
      {
        "name": "Exists",
        "description": "True if an active element exists in the mesh, false otherwise"
      }
    ],
    "properties": "Domain\nWhich domain to return the index of.",
    "notes": [
      {
        "type": "note",
        "text": "This node can only be used in the Tool context."
      }
    ]
  },
  "GeometryNodeInputID": {
    "label": "ID Node",
    "description": "The *ID* node gives an integer value indicating the stable random identifier of each element on the point domain,\nwhich is stored in the ``id`` attribute.\nThe node to set this data is the /modeling/geometry_nodes/geometry/write/set_id node.\nUnlike other built-in attributes, the ``id`` attribute does not always exist.\nIn that case, this node will output the index.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/read/id.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "ID",
        "description": "Integer value."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Unlike other built-in attributes, the ``id`` attribute does not always exist."
      }
    ]
  },
  "GeometryNodeInputNamedAttribute": {
    "label": "Named Attribute Node",
    "description": "The *Named Attribute* node outputs the data of an attribute based on the\ncontext of where it is connected (the field-context).",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/read/named_attribute.rst",
    "inputs": [
      {
        "name": "Name",
        "description": "The name of the attribute to read."
      }
    ],
    "outputs": [
      {
        "name": "Attribute",
        "description": "The attribute data stored on the geometry."
      },
      {
        "name": "Exists",
        "description": "True if the attribute accessed by the node is present in the connected context."
      }
    ],
    "properties": "Data Type\nThe data type used for the retrieved data.\ngeometry-nodes-attribute-search can be used to give a basic list of possible\nattribute names and data types. When a value is chosen from the search menu, the data\ntype is set to automatically choose the data type from the geometry nodes result."
  },
  "GeometryNodeConvexHull": {
    "label": "Convex Hull Node",
    "description": "The *Convex Hull* node outputs a convex mesh that is enclosing all points in the input geometry.\nWhen the node is used on a geometry with instances, the algorithm will run once per instance,\nresulting in many convex hull meshes in the instance geometries. The *Realize Instances* node can\nbe used to get a convex hull of an entire geometry.\nVolumes are not supported by this node, and attributes are not automatically transferred to the result.\nThis node is affected by the limitations of floating point precision. If points are too close together,\nthey may be merged in the result mesh.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/convex_hull.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      }
    ],
    "outputs": [
      {
        "name": "Convex Hull",
        "description": "Mesh that encloses all points in the input."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "When the node is used on a geometry with instances, the algorithm will run once per instance,"
      },
      {
        "type": "note",
        "text": "This node is affected by the limitations of floating point precision. If points are too close together,"
      }
    ]
  },
  "GeometryNodeSeparateGeometry": {
    "label": "Separate Geometry Node",
    "description": "The *Separate Geometry* node produces two geometry outputs. Based on the *Selection* input,\nthe input geometry is split between the two outputs.\nThis node can be combined with the /modeling/geometry_nodes/utilities/math/compare\nfor a more precise control of which parts are separated to a given output geometry.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/separate_geometry.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard Geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field used to calculate which output each part of the geometry will go to.\nParts in the selection will move to the *Selection* output.\nParts not in the selection will move to the *Inverted* output."
      }
    ],
    "outputs": [
      {
        "name": "Selection",
        "description": "The parts of the geometry in the selection."
      },
      {
        "name": "Inverted",
        "description": "The parts of the geometry not in the selection."
      }
    ],
    "properties": "Domain\nThe domain on which the selection field is evaluated.\nThe selection is on the points, control points, and vertices of the geometry.\nThe selection is on the edges of the mesh component. The other components\nare not modified.\nThe selection is on the faces of the mesh component. The other components\nare not modified.\nThe selection is on the splines in the curve component. For each spline, it\nis either entirely in the selection or not at all. The other components are not\nmodified.\nWhen selecting a domain that doesn't modify all components, the unmodified\ncomponents will appear in both outputs.",
    "notes": [
      {
        "type": "tip",
        "text": "This node can be combined with the /modeling/geometry_nodes/utilities/math/compare"
      },
      {
        "type": "note",
        "text": "When selecting a domain that doesn't modify all components, the unmodified"
      }
    ]
  },
  "GeometryNodeTransform": {
    "label": "Transform Geometry Node",
    "description": "The *Transform Geometry Node* allows you to move, rotate or scale the geometry.\nThe transformation is applied to the entire geometry, and not per element.\nThe /modeling/geometry_nodes/geometry/write/set_position is used for moving\nindividual points of a geometry. For transforming instances individually, the instance\ntranslate,\nrotate, or\nscale nodes can be used.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/transform_geometry.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Mode",
        "description": "How the transformation is specified."
      },
      {
        "name": "Translation",
        "description": "Translation of the entire geometry in the local space of the modified object."
      },
      {
        "name": "Rotation",
        "description": "Euler rotation in the local space of the modified object."
      },
      {
        "name": "Scale",
        "description": "Scale for the geometry in the local space of the modified object."
      },
      {
        "name": "Transform",
        "description": "A Transformation Matrix, available when using *Matrix* mode."
      }
    ]
  },
  "GeometryNodeDeleteGeometry": {
    "label": "Delete Geometry Node",
    "description": "The *Delete Geometry* node removes the selected part of a geometry.\nIt behaves similarly to the Delete tool in Edit Mode.\nThe type of elements to be deleted can be specified with the domain and mode properties.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/delete_geometry.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field that is true for parts of the geometry to be deleted."
      }
    ],
    "properties": "Domain\nThe domain on which the selection field is evaluated.\nThe selection is on the points, control points, and vertices of the geometry.\nThe selection is on the edges of the mesh component. The other components\nare not modified.\nThe selection is on the faces of the mesh component. The other components\nare not modified.\nThe selection is on the splines in the curve component. For each spline, it\nwill either be deleted entirely or not at all. The other components are not\nmodified.\nThe selection is on the top-level instances, and the entire instance is\nremoved if it is selected. If the input also contains realized geometry,\nthat will be unaffected.\nMode\nThe type of elements to be affected.\nThis only applies to the mesh component.\nVertices, edges, and faces in the selection will be deleted.\nVertices won't be deleted, even if they are in the selection.\nOnly faces in the selection will be deleted."
  },
  "GeometryNodeSeparateComponents": {
    "label": "Separate Components Node",
    "description": "The *Separate Components* node splits a geometry into a separate output\nfor each type of data in the geometry.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/separate_components.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Mesh component of the input geometry."
      },
      {
        "name": "Curve",
        "description": "Curve component of the input geometry."
      },
      {
        "name": "Point Cloud",
        "description": "Point cloud component of the input geometry."
      },
      {
        "name": "Volume",
        "description": "Volume component of the input geometry."
      },
      {
        "name": "Instances",
        "description": "Instances component of the input geometry. Even if the instances contain geometry data with\none of the other types, all instances will be added to this output.\nA /modeling/geometry_nodes/instances/realize_instances can be added to move the data from\ngeometry instances to their corresponding outputs."
      }
    ]
  },
  "GeometryNodeBake": {
    "label": "Bake Node",
    "description": "The *Bake* node allows saving and loading intermediate geometries.\nThis node bakes parts of the node tree for better performance.\nThe data format used to store geometry data is not considered to be an import/export format.\nVolume objects, however, are saved using the OpenVDB file format which can be used interoperably.\n- It's not guaranteed that data written with one Blender version can be read by another Blender version.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/bake.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input, which is used as the default bake item.\nMore bake items can be added by dragging sockets into the blank socket or in the *Bake Items* panel.\nItems can be renamed by Ctrl-LMB on the socket name or in the nodes *Properties* panel."
      }
    ],
    "outputs": [
      {
        "name": "For each input, the same output is added to act as a pass through.",
        "description": ""
      },
      {
        "name": "Geometry",
        "description": "Standard geometry output, which is used as the default bake item.\nMore bake items can be added by dragging sockets into the blank socket or in the *Bake Items* panel.\nItems can be renamed by Ctrl-LMB on the socket name or in the nodes *Properties* panel."
      }
    ],
    "properties": "Some properties can only be edited in the Properties panel\n(Sidebar --> Node --> Properties).\nBake Mode\nThe *Bake* node can calculate the geometry of a single frame or an animation.\nBakes the geometry data for multiple frames.\nBy default the scene frame range is used, however, a *Custom Range* can also be defined.\nBake\nPerforms all necessary geometry calculations and saves the data on disk or packed into the .blend file.\nPack/Unpack\nPacks or unpacks already baked data. When unpacking, there are different options to control where the data will\nbe stored. The options are the same as for the Unpack Resources operator.\ntrash Delete Geometry Node Bake\nDeletes the bake data.\nBake Target\nSpecifies where the baked data should be stored.\nThe setting is copied from the modifier that contains the bake node. This is the default.\nThe baked data is packed into the .blend file. So no separate file is necessary.\nThe baked data is stored in a separate directory on disk.\nCustom Path\nSpecify a path where the baked data should be stored manually.\nBake Path\nLocation on disk where the baked data is stored.\nNote, this path is also used for simulation zones.\nCustom Range Animation\nOverride the simulation frame range from the scene.\nStart, End\nThe start and end frame numbers for the custom range.",
    "notes": [
      {
        "type": "note",
        "text": "Some properties can only be edited in the Properties panel"
      }
    ]
  },
  "GeometryNodeDisplaceGeometry": {
    "label": "Displace Geometry Node",
    "description": "The *Displace Geometry* node moves geometry elements along a specified direction or vector,\noffsetting their positions to create deformations or surface displacements.\nIt can be used to apply procedural surface detail, simulate wave-like motion, or modify\nshapes based on fields such as textures or vertex attributes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/displace_geometry.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "The input geometry to displace."
      },
      {
        "name": "Selection",
        "description": "Determines which elements of the geometry are affected by the displacement.\nUnselected elements remain unchanged."
      },
      {
        "name": "Strength",
        "description": "The distance to move each element along the chosen offset direction or vector."
      },
      {
        "name": "Offset Method",
        "description": "Determines how the displacement direction is defined."
      },
      {
        "name": "Offset Distance Normal",
        "description": "The displacement distance when using *Normal* mode."
      },
      {
        "name": "Offset Vector Vector",
        "description": "The displacement vector when using *Vector* mode.\nThe vector is normalized internally unless otherwise specified."
      },
      {
        "name": "Substeps",
        "description": "The number of intermediate steps to divide the displacement into.\nFields, including normal and position, are re-evaluated at each substep for more stable\nor accurate iterative results."
      },
      {
        "name": "Post Substep Process",
        "description": "A /modeling/geometry_nodes/utilities/closure/index\nthat defines a geometry operation to apply after each substep of the displacement.\nThis allows additional geometry processing to be performed during the iterative displacement.\nThe closure has the following parameters:\n- Geometry -- The geometry at the current substep.\n- Selection -- The selected elements at that stage.\n- Strength -- The displacement strength for the substep.\n- Substep Index -- The current substep iteration number.",
        "parameters": [
          {
            "name": "Geometry",
            "description": "The geometry at the current substep."
          },
          {
            "name": "Selection",
            "description": "The selected elements at that stage."
          },
          {
            "name": "Strength",
            "description": "The displacement strength for the substep."
          },
          {
            "name": "Substep Index",
            "description": "The current substep iteration number."
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "The displaced geometry after applying the offset according to the specified method and parameters."
      }
    ]
  },
  "GeometryNodeSortElements": {
    "label": "Sort Elements Node",
    "description": "The *Sort Elements* node rearranges geometry elements by changing their indices.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/sort_elements.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "The selection of elements to sort, if left blank, all elements are sorted.\nNon-selected elements will keep their current indices."
      },
      {
        "name": "Group ID",
        "description": "Elements with the same group ID are sorted together.\nIf the connected socket is not a field, this socket has no effect."
      },
      {
        "name": "Sort Weight",
        "description": "The sorted values used to do the reordering.\nIf the connected socket is is not a field, this socket has no effect."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ],
    "properties": "Domain\nThe domain on which the selection and group ID fields are evaluated.\nThe fields are evaluated on points, control points, and vertices.\nThe fields are evaluated on the edges of the mesh component.\nThe fields are evaluated on the faces of the mesh component.\nThe fields are evaluated on the splines in the curve component.\nThe fields are evaluated on the top-level instances. Realized instances are ignored."
  },
  "GeometryNodeSplitToInstances": {
    "label": "Split To Instances Node",
    "description": "Splits a selection of geometry elements (such as faces) into groups,\nthen turns each group into an instance.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/split_to_instances.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field indicating which geometry elements to include."
      },
      {
        "name": "Group ID",
        "description": "Integer field indicating which group each element belongs to. Elements with the\nsame ID will be moved into the same output instance."
      }
    ],
    "properties": "Domain\nThe type of geometry to extract and split.\nThis is also the domain on which the *Selection* and *Group ID* fields are evaluated.\nPoints, spline control points, and vertices.\nMesh edges.\nMesh faces.\nCurve splines.\nTop-level instances. Realized instances are ignored.\nGrease Pencil layers.\nGeometry that doesn't match the selected domain will be removed.\nFor example, if you choose *Edge*, any faces, splines, and instances in the input\ngeometry will be lost.",
    "notes": [
      {
        "type": "note",
        "text": "Geometry that doesn't match the selected domain will be removed."
      }
    ]
  },
  "GeometryNodeDuplicateElements": {
    "label": "Duplicate Elements Node",
    "description": "The *Duplicate Elements* node creates a new geometry with the specified elements\nfrom the input duplicated an arbitrary number of times. The positions of elements\nare not changed, so all of the duplicates will be at the exact same location.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/duplicate_elements.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field that is true for parts of the geometry to be deleted."
      },
      {
        "name": "Amount",
        "description": "Field indicating how many times each input element should be duplicated.\nIf the value is zero for an element, it will not be included in the output at all."
      }
    ],
    "properties": "Domain\nThe type of geometry element to duplicate\nDuplicate the points of meshes, curves, or point clouds.\nAny other elements will not be included in the output.\nDuplicate mesh edges. Faces will not be included in the output.\nDuplicate mesh faces. Each duplicated face will be separate,\nin other words they will not share edges with other faces.\nIndividual curves from the input curves component will be duplicated.\nInput top-level instances will be duplicated."
  },
  "GeometryNodeBoundBox": {
    "label": "Bounding Box Node",
    "description": "The *Bounding Box* node creates a box mesh with the minimum volume that encapsulates\nthe geometry of the input. The node also can output the vector positions of the bounding dimensions.\nThe mesh output and the *Min* and *Max* outputs do not take instances into account. Instead,\nfor instanced geometry, a bounding box is computed for each instance rather than the whole geometry.\nTo compute the bounding box including the instances,\na /modeling/geometry_nodes/instances/realize_instances can be used.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/bounding_box.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Use Radius",
        "description": "For curves, point clouds, and Grease Pencil objects,\ninclude the ``radius`` attribute when calculating the bounds."
      }
    ],
    "outputs": [
      {
        "name": "Bounding Box",
        "description": "The resulting box that encapsulate the input geometry."
      },
      {
        "name": "Min",
        "description": "The coordinates corresponding to the box's -X, -Y, -Z position values,\ni.e. how far the box extends in each of the negative axes directions."
      },
      {
        "name": "Max",
        "description": "The coordinates corresponding to the box's +X, +Y, +Z position values,\ni.e. how far the box extends in each of the positive axes directions."
      }
    ]
  },
  "GeometryNodeMergeByDistance": {
    "label": "Merge by Distance Node",
    "description": "The *Merge by Distance* node merges selected mesh vertices or point cloud points within a given distance,\nmerging surrounding geometry where necessary. This operation is similar to the bpy.ops.mesh.remove_doubles\noperator or the /modeling/modifiers/generate/weld.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/operations/merge_by_distance.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Boolean field that is true for parts of the geometry to be deleted.\nUnselected points will be completely unused for the operation--\nthey will not be merged into other points, and no points will merge into them either.\nWhen possible, using the selection input can be a simple way to speed up the node,\nsince searching for nearby points is a relatively expensive operation that gets even\nmore expensive when more points are involved."
      },
      {
        "name": "Mode",
        "description": "Method for choosing which vertices are merged."
      },
      {
        "name": "Distance",
        "description": "The distance to use for searching for nearby points."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "When possible, using the selection input can be a simple way to speed up the node,"
      }
    ]
  },
  "GeometryNodeIndexOfNearest": {
    "label": "Index of Nearest",
    "description": "The Index of Nearest node is a way to find other close elements in the same geometry.\nIf needed you can use Group ID to determine the group of neighbors to be analyzed together.\nThis is an alternative to the /modeling/geometry_nodes/geometry/sample/sample_nearest node.\nThe main difference is that this node does not require a geometry input, because the geometry\nfrom the field context is used.\nThis is often combined with the /modeling/geometry_nodes/utilities/field/evaluate_at_index or\nthe /modeling/geometry_nodes/geometry/sample/sample_index node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/sample/index_of_nearest.rst",
    "inputs": [
      {
        "name": "Position",
        "description": "The position for each element to search.\nBy default, this is the same as if the /modeling/geometry_nodes/geometry/read/position was connected."
      },
      {
        "name": "Group ID",
        "description": "ID to group elements together."
      }
    ],
    "outputs": [
      {
        "name": "Index",
        "description": "The index\nof the closest element in the same geometry component."
      },
      {
        "name": "Has Neighbor",
        "description": "This is true when the group of the element has at least two elements.\nThis is only relevant when using *Group ID*."
      }
    ],
    "notes": [
      {
        "type": "tip",
        "text": "This is often combined with the /modeling/geometry_nodes/utilities/field/evaluate_at_index or"
      }
    ]
  },
  "GeometryNodeSampleIndex": {
    "label": "Sample Index Node",
    "description": "The *Sample Index* node retrieves values from a source geometry at a specific index.\nIf the *Geometry* used for the input is the same as the geometry from the field context,\nthis node is equivalent to the /modeling/geometry_nodes/utilities/field/evaluate_at_index. Using that node\nis usually preferable since avoiding the geometry socket makes the whole setup easier to use in other situations\nand share.\nThe Point domain is shared by different components (Mesh, Point Cloud, Curve).\nThis node simply samples the *Value* from the first non-empty component,\nchecked in the order: Mesh, Point Cloud, Curve.\nThe /modeling/geometry_nodes/geometry/operations/separate_components can be used to sample directly from a\nspecific component.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/sample/sample_index.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "The geometry to retrieve the attribute from."
      },
      {
        "name": "Value",
        "description": "A field to evaluate on the source *Geometry*. The values are then retrieved from specific\nindices for the output."
      },
      {
        "name": "Index",
        "description": "Which index to use when retrieving the data from the input *Value* field. Any index can be\nconnected, resulting in a \"shuffling\" of the values."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "The data retrieved from the source *Geometry* input."
      }
    ],
    "properties": "Data Type\nThe data type to use for the retrieved values.\nDomain\nThe attribute domain that the attribute is transferred from, or in other words,\nthe domain used to evaluate the *Attribute* input. For example, it is possible to transfer data from the\nfaces of one geometry to the points of another.\nClamp\nClamp the indices to the size of the attribute domain instead of outputting a default value for invalid indices.",
    "notes": [
      {
        "type": "tip",
        "text": "If the *Geometry* used for the input is the same as the geometry from the field context,"
      },
      {
        "type": "tip",
        "text": "The Point domain is shared by different components (Mesh, Point Cloud, Curve)."
      }
    ]
  },
  "GeometryNodeSampleNearest": {
    "label": "Sample Nearest Node",
    "description": "The *Sample Nearest* node retrieves the index\nof the geometry element in its input geometry that is closest to the input position.\nThis node is similar to the /modeling/geometry_nodes/geometry/sample/geometry_proximity,\nbut it outputs the index of the closest element instead of its distance from the current location.\nIf you want to find nearest to each point in same geometry, its better to use\nthe /modeling/geometry_nodes/geometry/sample/index_of_nearest node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/sample/sample_nearest.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "The geometry to sample.\nThis node only supports point cloud and mesh inputs."
      },
      {
        "name": "Sample Position",
        "description": "The position to start from when finding the closest location on the target geometry.\nBy default, this is the same as if the /modeling/geometry_nodes/geometry/read/position was connected."
      }
    ],
    "outputs": [
      {
        "name": "Index",
        "description": "The index of the closest geometry element of the\nchosen domain. For the *Face Corner* domain this is defined to be the closest corner on the closest face."
      }
    ],
    "properties": "Domain\nThe attribute domain to consider the distance from.",
    "notes": [
      {
        "type": "tip",
        "text": "If you want to find nearest to each point in same geometry, its better to use"
      },
      {
        "type": "note",
        "text": "This node only supports point cloud and mesh inputs."
      }
    ]
  },
  "GeometryNodeRaycast": {
    "label": "Raycast Node",
    "description": "The *Raycast* node intersects rays from one geometry onto another. The source geometry is defined by\nthe context of the node that the *Raycast* node is connected to.\nEach ray computes hit points on the target mesh and outputs normals, distances\nand any surface attribute specified.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/sample/raycast.rst",
    "inputs": [
      {
        "name": "Target Geometry",
        "description": "Geometry that rays are tested against."
      },
      {
        "name": "Attribute",
        "description": "An optional field input evaluated on the *Target Geometry* that will be interpolated at the hit points.\nThe resulting values are outputted with the *Attribute* output."
      },
      {
        "name": "Interpolation",
        "description": "How attributes of the target mesh are mapped to the attribute values on the result geometry.\nVertex and corner attributes are interpolated smoothly, with a bilinear function.\nChoose the value of the closest vertex without interpolating."
      },
      {
        "name": "Source Position",
        "description": "The position from where to start each ray. By default, this is the same as\nif the /modeling/geometry_nodes/geometry/read/position was connected."
      },
      {
        "name": "Ray Direction",
        "description": "Direction of each ray from the starting position.\nThe field is evaluated on the geometry from the context of the field evaluation, not the *Target Geometry*."
      },
      {
        "name": "Ray Length",
        "description": "Maximum distance a ray can travel before being considered \"no hit\"."
      }
    ],
    "outputs": [
      {
        "name": "Is Hit",
        "description": "Boolean output that is true for each ray which has hit the *Target Geometry*."
      },
      {
        "name": "Hit Position",
        "description": "The location of the intersection point with the target mesh."
      },
      {
        "name": "Hit Normal",
        "description": "The surface Normal vector at the hit location."
      },
      {
        "name": "Hit Distance",
        "description": "The distance from the *Source Position* to the *Hit Position*.\nIf the ray does not hit, the *Ray Length* is returned."
      },
      {
        "name": "Attribute",
        "description": "Interpolated values of the *Attribute* input sampled at the *Hit Position*."
      }
    ],
    "properties": "Data Type\nThe data type used for the evaluated data."
  },
  "GeometryNodeProximity": {
    "label": "Geometry Proximity Node",
    "description": "The *Geometry Proximity* node computes the closest location on the target geometry.\nThe /modeling/geometry_nodes/utilities/math/map_range is often helpful to use with the distance\noutput of this node to create a falloff with a maximum distance.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/sample/geometry_proximity.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Group ID",
        "description": "Splits the elements of the input geometry into groups which can be sampled individually."
      },
      {
        "name": "Sample Position",
        "description": "The given position to calculate the closest location on the target."
      },
      {
        "name": "Sample Group ID",
        "description": "Determines in which group the closest nearest element is detected."
      }
    ],
    "outputs": [
      {
        "name": "Position",
        "description": "Closest location on the surface of the target mesh, or the closest point in the target point cloud\nin *Points* mode."
      },
      {
        "name": "Distance",
        "description": "Distance (as floating-point value) from the source position to the closest location in the target."
      },
      {
        "name": "Is Valid",
        "description": "Whether the sampling was successful. It can fail when the sampled group is empty."
      }
    ],
    "properties": "Target Element\nCalculate the closest point anywhere on the faces of the target's mesh geometry.\nCalculate the closest point anywhere on the edges of the target's mesh geometry.\nCalculate the closest point or vertex on the target geometry. This mode is usually the fastest.\nThis mode works for both point cloud and mesh geometry, the other modes only work for meshes.",
    "notes": [
      {
        "type": "tip",
        "text": "The /modeling/geometry_nodes/utilities/math/map_range is often helpful to use with the distance"
      }
    ]
  },
  "GeometryNodeMaterialSelection": {
    "label": "Material Selection Node",
    "description": "The *Material Selection* node provides a selection for meshes that use this material.\nSince the ``material_index`` is stored on each face, the output will be implicitly interpolated to\na different domain when necessary. For example, every vertex connected to\na selected face will be selected.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/material/material_selection.rst",
    "inputs": [
      {
        "name": "Material",
        "description": "Standard material input."
      }
    ],
    "outputs": [
      {
        "name": "Selection",
        "description": "Selection of faces that use the input material."
      }
    ]
  },
  "GeometryNodeSetMaterialIndex": {
    "label": "Set Material Index Node",
    "description": "The *Set Material Index* node sets the material index for a geometry.\nThe node to get this data is the Material Index\nnode.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/material/set_material_index.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Selection",
        "description": "Whether to change the material index for each face.\nTrue values mean the material index will be changed, false values mean it will remain the same."
      },
      {
        "name": "Material Index",
        "description": "The new material index."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ]
  },
  "GeometryNodeSetMaterial": {
    "label": "Set Material Node",
    "description": "The *Set Material* changes the material assignment in the specified selection,\nby adjusting the ``material_index`` attribute. If the material is already used\non the geometry, the existing material index will be reused.\nThis node adjusts mesh, point clouds, and volume data;\nother data types do not support materials.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/material/set_material.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input containing a mesh."
      },
      {
        "name": "Material",
        "description": "The material to apply to the geometry."
      },
      {
        "name": "Selection",
        "description": "Whether to change the material of each face.\nTrue values mean the material will be changed, false values mean it will remain the same.\nNote, volumes and point clouds only support a single material,\nin these cases a field input will be ignored."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "This node adjusts mesh, point clouds, and volume data;"
      }
    ]
  },
  "GeometryNodeReplaceMaterial": {
    "label": "Replace Material Node",
    "description": "The *Replace Material* node swaps one material with another.\nReplacing a material with this node is more efficient than creating a selection of all faces\nwith the old material with the /modeling/geometry_nodes/geometry/material/material_selection\nand then using the /modeling/geometry_nodes/geometry/material/set_material.\nCurrently this node only adjusts mesh data.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/material/replace_material.rst",
    "inputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry input."
      },
      {
        "name": "Old",
        "description": "Material that is going to be replaced."
      },
      {
        "name": "New",
        "description": "Material that is replacing the old material."
      }
    ],
    "outputs": [
      {
        "name": "Geometry",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Currently this node only adjusts mesh data."
      }
    ]
  },
  "GeometryNodeInputMaterialIndex": {
    "label": "Material Index Node",
    "description": "The *Material Index* node outputs which material in the list of materials of the geometry\neach element corresponds to. Currently the node supports mesh data, where ``material_index``\nis a built-in attribute on faces.\nThe node to set this data is\nthe Set Material Index node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/geometry/material/material_index.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "Material Index",
        "description": "Standard integer value, with a minimum value of zero."
      }
    ]
  },
  "GeometryNodeStoreNamedGrid": {
    "label": "Store Named Grid Node",
    "description": "The *Store Named Grid* node stores a voxel grid inside a volume geometry under a specified name.\nThis allows multiple grids (such as *density*, *temperature*, or *velocity*) to\nbe contained within a single volume object and accessed later using the\nGet Named Grid node.\nIf a grid with the same name already exists in the input volume, it will be replaced by the new grid.\nThis makes it possible to update or overwrite grids during a geometry node\nevaluation, for example when generating or modifying simulation fields.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/write/store_named_grid.rst",
    "inputs": [
      {
        "name": "Volume",
        "description": "The input volume geometry to which the grid will be added or replaced."
      },
      {
        "name": "Name",
        "description": "The name under which the grid will be stored in the volume.\nThis name is used later to retrieve the grid using the *Get Named Grid*\nnode or in the Spreadsheet editor under the *Volume Grids* section."
      },
      {
        "name": "Grid",
        "description": "The grid to store within the volume.\nThe grid must have a compatible resolution and transform with the target volume.\nThe grid's data type must match the node's *Data Type* property."
      }
    ],
    "outputs": [
      {
        "name": "Volume",
        "description": "The resulting volume geometry containing the newly stored grid.\nIf a grid with the same name previously existed, it is replaced with the\nnew one; otherwise, the grid is added as a new entry."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid (e.g. *Float*, *Integer*, *Boolean*, or *Vector*).\nDetermines the expected data type of the *Grid* input and ensures that the\ngrid is stored correctly in the volume container."
  },
  "GeometryNodeSetGridBackground": {
    "label": "Set Grid Background Node",
    "description": "The *Set Grid Background* node defines the background value for a voxel grid.\nThis value is used when sampling regions of the grid that do not contain any\nexplicitly stored voxels, such as inactive areas or tiles that have not been\ninitialized.\nBy default, empty voxels in a grid evaluate to zero or another implicit value.\nThis node allows customizing that behavior, which can be useful when\nconstructing grids procedurally or when combining multiple grids.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/write/set_grid_background.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input grid whose background value will be modified."
      },
      {
        "name": "Background",
        "description": "The value to assign to inactive or uninitialized voxels and tiles.\nWhen sampling outside the defined region of the grid, this value will be\nreturned instead of zero."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting grid with the updated background value applied.\nThis grid can be passed to other nodes such as\nSample Grid Index\nor Sample Grid\nto ensure consistent results in areas where the grid has no stored voxels."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid.\nDetermines the expected type of the *Background* input and the values the\ngrid can hold (e.g. *Float*, *Integer*, *Boolean*, Vector)."
  },
  "GeometryNodeSetGridTransform": {
    "label": "Set Grid Transform Node",
    "description": "The *Set Grid Transform* node defines the spatial transform of a voxel grid,\nconverting its index space (voxel coordinates) into object space.\nBy default, voxel grids use a transform that maps integer voxel indices\ndirectly to object space coordinates. This node allows specifying a custom\ntransform, enabling operations such as repositioning, rotating, or scaling\na grid relative to an object or scene.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/write/set_grid_transform.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input grid whose transform will be changed."
      },
      {
        "name": "Transform",
        "description": "The new transform from grid index space to object space.\nThis determines how the voxel grid is positioned and oriented in 3D space.\nTypically this input comes from a Transformation Matrix/"
      }
    ],
    "outputs": [
      {
        "name": "Is Valid",
        "description": "Outputs ``true`` if the provided transform was valid and successfully\napplied to the grid.\nThe new transform can fail to be applied if the input transform isn't\ninvertible or for some extremes of scaling (0 or combinations of negative and positive)."
      },
      {
        "name": "Grid",
        "description": "The resulting grid with the updated transform applied.\nThe new transform affects how the grid's voxel indices are interpreted\nin object space, which in turn changes how the grid interacts with other\ngeometry and sampling operations."
      }
    ],
    "properties": "Data Type\nThe data type of the grid to which the transform is applied.\nDetermines the kind of values stored in the grid\n(e.g. *Float*, *Integer*, *Boolean*, *Vector*), and must match the input grid's data type."
  },
  "GeometryNodeInputVoxelIndex": {
    "label": "Voxel Index Node",
    "description": "The *Voxel Index* node outputs the integer index of the voxel that the field\nis currently being evaluated on.\nUnlike a position in object space, the voxel index refers to the discrete\ncell coordinates inside a voxel grid. This makes it possible to reason\nabout neighboring voxels directly in index space, without converting\nthrough world or object space.\nThis node can be combined with nodes such as\nInteger Math\nand Sample Grid Index\nto sample values from nearby voxels by offsetting the indices.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/read/voxel_index.rst",
    "inputs": [
      {
        "name": "This node has no inputs.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "X, Y, Z",
        "description": "The integer indices of the current voxel in the grid along each axis.\nThese values identify which voxel is being sampled by the field at this\nevaluation point. They can be offset (for example, add or subtract 1 on X)\nand then passed to Sample Grid Index\nto read values from neighboring voxels."
      }
    ]
  },
  "GeometryNodeGridInfo": {
    "label": "Grid Info Node",
    "description": "The *Grid Info* node retrieves structural and metadata information about a voxel grid.\nIt provides details such as the grid's spatial transform and background value,\nwhich describe how the grid is positioned in space and what value is stored in\ninactive (empty) voxels.\nThis node is useful for inspecting or reusing grid parameters in other grid\noperations, such as aligning transforms, matching resolutions, or reconstructing\nfields with consistent background values.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/read/grid_info.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input voxel grid to query information from."
      }
    ],
    "outputs": [
      {
        "name": "Transform",
        "description": "The transform matrix that converts from grid index space to object space.\nDefines how the grid's voxels are positioned, scaled, and oriented in 3D space.\nThis can be passed to nodes such as\nSet Grid Transform\nor used to align other grids or geometry."
      },
      {
        "name": "Background Value",
        "description": "The value assigned to inactive voxels in the grid.\nThis represents the default or \u201cempty\u201d value used when sampling outside of active regions, as set by the\nSet Grid Background\nnode or similar operations."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid (e.g. *Float*, *Integer*, *Boolean*, or *Vector*).\nDetermines both the expected data type of the *Grid* input and the type of\nthe *Background Value* output."
  },
  "GeometryNodeGetNamedGrid": {
    "label": "Get Named Grid Node",
    "description": "The *Get Named Grid* node retrieves a specific voxel grid from a volume geometry by its name.\nEach volume object can contain multiple grids (for example, *density*, *color*,\n*temperature*, or *velocity*), and this node allows accessing one of them for\nfurther processing in the node tree.\nThe retrieved grid can then be sampled, modified, or converted to geometry\nusing other grid or SDF nodes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/read/get_named_grid.rst",
    "inputs": [
      {
        "name": "Volume",
        "description": "The input volume geometry that contains one or more named grids."
      },
      {
        "name": "Name",
        "description": "The name of the grid to retrieve from the volume.\nThe name must match an existing grid stored in the volume data block."
      },
      {
        "name": "Remove",
        "description": "When enabled, removes the grid from the volume after it has been retrieved.\nThis can be useful when restructuring volume data to avoid duplication or\nmanage memory more efficiently."
      }
    ],
    "outputs": [
      {
        "name": "Volume",
        "description": "The resulting volume geometry after optionally removing the retrieved grid."
      },
      {
        "name": "Grid",
        "description": "The extracted grid corresponding to the given *Name* and *Data Type*.\nThis grid can be passed to other nodes such as\nSample Grid or\nGrid to Mesh\nfor further manipulation or conversion."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid (e.g. *Float*, *Integer*, *Boolean*, or *Vector*).\nDetermines both the expected data type of the *Grid* output and how it can\nbe used in subsequent nodes."
  },
  "GeometryNodeSDFGridFillet": {
    "label": "SDF Fillet Node",
    "description": "The *SDF Fillet* node smooths or rounds off concave internal corners in a Signed Distance Field (SDF) grid.\nIt modifies the field to produce softer transitions between surfaces that meet\nat sharp inward angles, similar to adding a *fillet* or *bevel* in mesh modeling.\nThis operation only affects regions with negative principal curvature\n(concave corners) and preserves overall volume. The result is a more organic\nand continuous surface, useful for soft blending of intersecting shapes or\nremoving hard transitions after boolean operations.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/sdf_grid_fillet.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input SDF grid to be smoothed.\nTypically generated from another SDF operation such as a boolean or mesh conversion."
      },
      {
        "name": "Iterations",
        "description": "The number of smoothing iterations to apply.\nHigher values produce a larger, smoother fillet radius but also increase computation time.\nA single iteration results in a subtle rounding, while multiple iterations\ncreate progressively softer surfaces."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting SDF grid with concave corners rounded off.\nThe output can be visualized by converting it to a mesh with\nGrid to Mesh or\nused in further volumetric operations."
      }
    ]
  },
  "GeometryNodeGridPrune": {
    "label": "Prune Grid Node",
    "description": "The *Prune Grid* node optimizes the storage of a voxel grid by collapsing\nuniform regions into coarser tiles or inner nodes, reducing memory usage and\nimproving performance.\nThis node performs the inverse operation of the\nVoxelize Grid node.\nWhile voxelization expands sparse tiles into dense voxels, pruning\ndetects large uniform areas and replaces them with more compact representations.\nThis is especially useful after operations that create large\nregions of constant values, such as filling, clipping, or thresholding.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/prune_grid.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input grid to optimize."
      },
      {
        "name": "Mode",
        "description": "The pruning method used to simplify the grid structure:\nTurns inactive voxels and tiles into inactive background tiles.\nThis is the simplest mode and provides basic cleanup for grids with\nempty or unused regions.\nCollapses regions where all voxels have approximately the same value and\nactive state (within a given tolerance threshold) into background tiles.\nThis is useful for fog or scalar grids where smooth variations may leave\nnear-uniform areas that can be simplified.\nSpecialized mode for signed distance field (SDF) grids.\nReplaces inactive tiles with inactive nodes, providing faster and more\ntargeted pruning without the need for threshold comparison.\nThis mode is efficient for narrow-band SDFs that contain large interior\nor exterior regions of constant sign."
      },
      {
        "name": "Threshold Threshold",
        "description": "Voxels within a region are considered uniform if the difference between\ntheir values is less than this amount. Higher thresholds allow more\naggressive simplification, while smaller values preserve finer details."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting grid with optimized storage. Uniform regions are collapsed\ninto larger tiles or nodes, resulting in a more compact and efficient\nrepresentation."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid (e.g. *Float*, *Integer*, *Boolean*,\n*Vector*).\nMust match the type of the input grid."
  },
  "GeometryNodeSDFGridMeanCurvature": {
    "label": "SDF Grid Mean Curvature Node",
    "description": "The *SDF Grid Mean Curvature* node applies mean curvature flow smoothing to a Signed Distance Field (SDF) grid.\nThis operation evolves the surface of the field over time based on its mean curvature,\ncausing high-curvature (sharp or noisy) regions to smooth out more rapidly than flatter areas.\nUnlike simple averaging or Laplacian smoothing, mean curvature flow adapts to\nthe geometric features of the surface, providing a more natural, shape-preserving\nsmoothing process. It can be used to refine complex SDF surfaces, remove small\nartifacts, and create organically blended transitions between features.\nThis node is particularly effective after boolean operations or mesh-to-SDF\nconversion, where the resulting fields may contain high-frequency noise.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/sdf_grid_mean_curvature.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input signed distance field to smooth.\nTypically, the grid represents a surface or volume generated from a mesh or procedural operation."
      },
      {
        "name": "Iterations",
        "description": "The number of mean curvature flow iterations to apply.\nEach iteration progressively smooths the surface, with higher values\nresulting in a more pronounced smoothing effect.\nA small number of iterations will gently polish the surface, while\nlarger values can significantly alter its shape."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting SDF grid after mean curvature flow smoothing.\nThe output surface has reduced high-curvature noise and smoother transitions,\nwhile retaining major structural features of the original shape."
      }
    ]
  },
  "GeometryNodeSDFGridOffset": {
    "label": "SDF Grid Offset Node",
    "description": "The *SDF Grid Offset* node offsets the surface of a Signed Distance Field (SDF)\nby a specified world-space distance.\nThis operation effectively dilates (expands) or erodes (contracts) the\nsurface while maintaining the correct signed distance values across the field.\nA positive offset increases the surface thickness by pushing it outward,\nwhile a negative offset shrinks it inward. This is a fundamental operation in\nvolumetric modeling, useful for adjusting wall thickness, creating shells,\nexpanding collision volumes, or controlling blend margins between shapes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/sdf_grid_offset.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input signed distance field to offset."
      },
      {
        "name": "Distance",
        "description": "The offset distance applied to the surface, in world units.\nPositive values expand the surface (dilation), and negative values contract it (erosion).\nThe offset is applied uniformly in all directions, preserving smoothness and the signed distance property."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting SDF grid with the surface offset by the specified distance.\nThe output preserves the SDF property, ensuring that distances remain\naccurate for subsequent operations such as booleans or conversion to a mesh."
      }
    ]
  },
  "GeometryNodeFieldToGrid": {
    "label": "Field to Grid Node",
    "description": "The *Field to Grid* node creates one or more new voxel grids by evaluating\ngeometry fields on the topology of an existing grid.\nThis allows generating new volumetric data (such as density, temperature,\nvelocity, or distance fields) directly from field inputs defined in the node\ntree.\nEach input field is sampled at the voxel positions of the provided topology\ngrid, producing a corresponding output grid that matches the same resolution,\ntransform, and domain.\nThis enables consistent evaluation of multiple attributes or procedural\nquantities across the same volume structure.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/field_to_grid.rst",
    "inputs": [
      {
        "name": "Topology",
        "description": "The reference grid whose voxel layout, resolution, and transform define\nwhere the input fields will be evaluated."
      },
      {
        "name": "Additional input sockets can be added for each field to be evaluated.",
        "description": ""
      },
      {
        "name": "Each field defines a scalar or vector value to sample on the topology grid.",
        "description": ""
      },
      {
        "name": "Fields can be added by dragging them into the blank socket area.",
        "description": ""
      }
    ],
    "outputs": [
      {
        "name": "For each field input, a separate grid output is created that contains the",
        "description": ""
      },
      {
        "name": "evaluated voxel data.",
        "description": ""
      },
      {
        "name": "All output grids share the same topology as the input grid, ensuring that",
        "description": ""
      },
      {
        "name": "they are aligned and compatible for further processing or combination.",
        "description": ""
      }
    ],
    "properties": "In the properties panel, each field input can be configured individually.\nThis includes setting its data type (such as *Float*, *Vector*, or *Boolean*)\nand managing the order of evaluation.\nEach field input produces a corresponding output grid.",
    "notes": [
      {
        "type": "note",
        "text": "When a color field is connected, it will be evaluated as a *Vector* data"
      }
    ]
  },
  "GeometryNodeSDFGridLaplacian": {
    "label": "SDF Grid Laplacian Node",
    "description": "The *SDF Grid Laplacian* node applies Laplacian flow smoothing to a Signed Distance Field (SDF) grid.\nThis process gradually smooths the surface of the SDF by diffusing fine\ndetails and noise across neighboring voxels, resulting in a cleaner, more uniform field.\nLaplacian flow is a computationally efficient alternative to\nmean curvature flow\nsmoothing. It is particularly useful for refining SDFs generated from\nmeshes or boolean operations, where sharp transitions or voxel artifacts may occur.\nThe operation helps improve the quality of surfaces before converting the SDF back into a mesh.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/sdf_grid_laplacian.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input signed distance field to be smoothed."
      },
      {
        "name": "Iterations",
        "description": "The number of Laplacian smoothing iterations to apply.\nEach iteration progressively diffuses high-frequency surface variations,\nreducing surface noise.\nHigher values increase smoothness but may cause slight surface shrinkage."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting SDF grid after Laplacian flow smoothing.\nThe output surface is smoother and more continuous, while preserving\nthe main shape features of the original field."
      }
    ]
  },
  "GeometryNodeSDFGridMedian": {
    "label": "SDF Grid Median Node",
    "description": "The *SDF Grid Median* node applies a median filter to a Signed Distance Field (SDF) grid.\nThis operation smooths the field by replacing each voxel value with the\nmedian of its neighboring values, effectively removing noise and small\nartifacts while preserving sharp features and edges.\nUnlike mean\nor Laplacian\nsmoothing, the median filter is non-linear and\nbetter suited for cleaning up impulsive noise (isolated spikes or dips) in\nthe grid. It maintains the overall structure and boundaries of the surface,\nmaking it useful for refining SDFs generated from noisy or voxelized meshes.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/sdf_grid_median.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input signed distance field to be filtered."
      },
      {
        "name": "Width",
        "description": "The radius of the median filter kernel, measured in voxels.\nLarger widths produce stronger smoothing by considering a wider\nneighborhood around each voxel."
      },
      {
        "name": "Iterations",
        "description": "The number of times the median filter is applied.\nMultiple iterations increase smoothing and noise reduction while\nmaintaining edge sharpness."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting SDF grid after median filtering.\nThe output has reduced high-frequency noise and artifacts while\nretaining sharp edges and important structural details of the surface."
      }
    ]
  },
  "GeometryNodeSDFGridBoolean": {
    "label": "SDF Grid Boolean Node",
    "description": "The *SDF Grid Boolean* node performs boolean operations between two or more\nSigned Distance Field (SDF) grids.\nThis allows combining, subtracting, or intersecting volumetric shapes directly\nin grid space, similar to mesh boolean operations but with smooth and continuous results.\nThe node computes the resulting signed distance field by applying mathematical\noperations to the input grids, preserving the SDF property where each voxel\nstores the shortest distance to the nearest surface.\nThis makes it useful for blending or sculpting complex volumes procedurally.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/sdf_grid_boolean.rst",
    "inputs": [
      {
        "name": "Grid Intersect",
        "description": "The input grid used for intersection operations.\nOnly the regions common to all intersecting grids will remain active."
      },
      {
        "name": "Grid 1 Union Difference",
        "description": "The first input grid for boolean combination.\nActs as the base grid to which the second grid is added or subtracted."
      },
      {
        "name": "Grid 2 Union Difference",
        "description": "The second input grid used to modify *Grid 1* according to the selected operation."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting SDF grid after the boolean operation is applied.\nThe output maintains valid signed distance values and can be converted\nto a mesh using the Grid to Mesh\nnode or used in further volumetric operations."
      }
    ],
    "properties": "Operation\nThe boolean operation to perform between the input SDF grids:\nKeeps only the overlapping region of the two grids where both contain\ninterior (negative) values.\nCombines both grids by taking the minimum distance at each voxel.\nThe resulting grid contains the merged shape of both inputs.\nSubtracts the second grid from the first by inverting its sign and then\ntaking the maximum distance.\nUseful for cutting holes or carving one SDF out of another."
  },
  "GeometryNodeGridVoxelize": {
    "label": "Voxelize Grid Node",
    "description": "The *Voxelize Grid* node converts all active tiles in a sparse voxel grid\ninto fully populated voxel regions, removing sparseness.\nIn voxel-based grids such as signed distance fields (SDF) or fog volumes,\ninactive areas are often stored as *tiles*\u2014compact representations that save\nmemory by not allocating individual voxel values. This node expands those tiles\ninto explicit voxels, making every voxel within an active tile directly\naccessible and editable.\nThis can be useful before performing operations that require dense voxel data,\nsuch as sampling, filtering, or arithmetic operations that depend on\nneighboring voxel values.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/voxelize_grid.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input grid to voxelize.\nTypically a sparse SDF or fog volume grid whose active tiles should be\nexpanded into dense voxels."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting grid with all active tiles converted into individual voxels.\nFor fog volumes, this means that interior sparse tiles are expanded into\nvoxels with individually adjustable values. For SDF grids, this produces a\nfully dense voxel representation suitable for precise sampling and editing."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid (e.g. *Float*, *Integer*, *Boolean*, *Vector*)."
  },
  "GeometryNodeSDFGridMean": {
    "label": "SDF Grid Mean Node",
    "description": "The *SDF Grid Mean* node applies mean (box) filter smoothing to amSigned Distance Field (SDF) grid.\nThis operation averages voxel values within a local neighborhood to smooth\nout small variations and noise while preserving the overall shape of the field.\nThe filter works as a fast, separable averaging operation\u2014sometimes called a\n*box filter*\u2014and is well suited for general-purpose smoothing or softening of\nSDF data after boolean, voxelization, or other volumetric operations.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/sdf_grid_mean.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input signed distance field to be smoothed."
      },
      {
        "name": "Width",
        "description": "The radius of the smoothing kernel in voxels.\nLarger values result in a broader smoothing effect, producing softer,\nless detailed surfaces. Smaller values restrict smoothing to immediate\nneighbors, retaining more fine detail."
      },
      {
        "name": "Iterations",
        "description": "The number of times the mean filter is applied.\nEach iteration increases the smoothness of the surface.\nMultiple passes can approximate a Gaussian-like blur effect."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting SDF grid after mean filtering.\nThe surface becomes smoother and more uniform, making it useful for\nrefining noisy or rough SDFs before further operations such as\nGrid to Mesh."
      }
    ]
  },
  "GeometryNodeVolumeToMesh": {
    "label": "Volume to Mesh Node",
    "description": "The *Volume to Mesh* node generates a mesh on the \"surface\" of a volume.\nThe surface is defined by a threshold value.\nAll voxels with a larger value than the threshold are considered to be inside.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/volume_to_mesh.rst",
    "inputs": [
      {
        "name": "Volume",
        "description": "Standard geometry input."
      },
      {
        "name": "Resolution Mode",
        "description": "Mode for how the resolution of the final mesh is controlled.\nThis makes the resolution dependent on the resolution of the grid that is converted.\nHigher resolution grids result in a higher resolution mesh.\nIn many cases, that is the most efficient mode.\nSpecifies the approximate resolution of the final mesh.\nThe voxel size is adapted to the size of the entire volume.\nUse a fixed resolution that does not change when the volume changes.\nThis option applies individually for every grid in the input geometry."
      },
      {
        "name": "Voxel Amount",
        "description": "Specifies the approximate resolution of the final mesh.\nThe voxel size is adapted to the size of the entire volume."
      },
      {
        "name": "Voxel Size",
        "description": "Use a fixed resolution that does not change when the volume changes."
      },
      {
        "name": "Threshold",
        "description": "Voxels with a larger value are considered to be inside the mesh.\nThe mesh will be generated on the boundary of inside and outside voxels.\nThis is also called \"iso value\"."
      },
      {
        "name": "Adaptivity",
        "description": "Reduces the final face count by simplifying geometry where detail is not needed.\nThis is similar to decimating the final to reduce resolution where it is not needed."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "Standard geometry output."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "This option applies individually for every grid in the input geometry."
      }
    ]
  },
  "GeometryNodeGridToMesh": {
    "label": "Grid to Mesh Node",
    "description": "The *Grid to Mesh* node converts a voxel grid into a polygonal mesh by\nextracting an isosurface at a specified threshold value.\nThis process is similar to the *Marching Cubes* algorithm used in many\nvolumetric modeling systems.\nThe resulting mesh represents the boundary where the grid's values cross the\ngiven threshold\u2014typically the surface of a signed distance field (SDF) or density grid.\nThis makes it possible to convert procedural volumetric data into geometry for\nrendering, simulation, or further modeling operations.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/operations/grid_to_mesh.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input voxel grid to convert into a mesh.\nThe grid must store float values such as those from a signed distance or density field."
      },
      {
        "name": "Threshold",
        "description": "The value that defines the surface of the generated mesh.\nVoxels with values larger than this threshold are considered *inside* the\nmesh, while smaller values are considered *outside*.\nFor SDF grids, a threshold of ``0.0`` typically corresponds to the surface."
      },
      {
        "name": "Adaptivity",
        "description": "Controls the simplification of the generated mesh based on curvature.\nHigher values reduce polygon count by merging nearly flat areas, while\nsmaller values preserve more detail.\nA value of ``0.0`` disables adaptivity and produces a uniform mesh density."
      }
    ],
    "outputs": [
      {
        "name": "Mesh",
        "description": "The resulting mesh extracted from the grid's isosurface.\nThe mesh follows the region where the grid's scalar values equal the\nspecified *Threshold*, and can be used for further geometry processing or rendering."
      }
    ]
  },
  "GeometryNodeVolumeCube": {
    "label": "Volume Cube Node",
    "description": "The *Volume Cube* generates a volume by evaluating a density field on a 3D grid.\nThe *Density* field can only depend on the /modeling/geometry_nodes/geometry/read/position.\nThe grid points are equally spaced between the *Min* and *Max* bounds of the grid.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/primitives/volume_cube.rst",
    "inputs": [
      {
        "name": "Density",
        "description": "The value for the new grid at each voxel."
      },
      {
        "name": "Background",
        "description": "The value of the grid outside the *Min*..*Max* grid bounds.\nVoxels with a density equal to the background are pruned, which can lead to more memory-efficient volumes."
      },
      {
        "name": "Min",
        "description": "Location of the left-most grid point and lower bound of the voxel volume."
      },
      {
        "name": "Max",
        "description": "Location of the right-most grid point and upper bound of the voxel volume."
      },
      {
        "name": "Resolution X,Y,Z",
        "description": "The number of grid points on each axis.\nThe grid contains one less full voxel on each axis than there are grid points.\nFor example a *Volume Cube* with resolution 10 has 9 voxels between the left and right grid points.\nChanging these values can have a significant impact on performance. For example, the default values\nof 32 mean the input field will be evaluated about 33 thousand times. Increasing the values to 100\nwill give 1 million evaluations, and 1000 would give 1 billion."
      }
    ],
    "outputs": [
      {
        "name": "Volume",
        "description": "Geometry containing the generated volume."
      }
    ],
    "notes": [
      {
        "type": "note",
        "text": "Changing these values can have a significant impact on performance. For example, the default values"
      }
    ]
  },
  "GeometryNodeGridCurl": {
    "label": "Grid Curl Node",
    "description": "The *Grid Curl* node computes the curl of a vector field stored in a voxel grid.\nCurl represents the local amount of rotational motion or circulation within\na vector field\u2014essentially, how much and in what direction the field \"spins\"\naround each point.\nIn mathematical terms, the curl of a 3D vector field F = (Fx, Fy, Fz) is a\nvector that describes the infinitesimal rotation of the field, defined as:\n\\nabla \\times \\mathbf{F} =\n\\left(\n\\frac{\\partial F_z}{\\partial y} - \\frac{\\partial F_y}{\\partial z}\n\\right) \\mathbf{\\hat{i}}\n+\n\\left(\n\\frac{\\partial F_x}{\\partial z} - \\frac{\\partial F_z}{\\partial x}\n\\right) \\mathbf{\\hat{j}}\n+\n\\left(\n\\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y}\n\\right) \\mathbf{\\hat{k}}\nThe resulting vector points along the axis of rotation, and its magnitude\nindicates the strength of that rotation.\nThis operation is useful for generating turbulence or analyzing the rotational\nbehavior of flow fields in simulations and procedural effects.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/sample/grid_curl.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input vector grid from which to calculate the curl.\nThe grid must store 3D vector values (e.g. velocity or direction fields)."
      }
    ],
    "outputs": [
      {
        "name": "Curl",
        "description": "A vector grid representing the curl (local rotation) of the input field.\nThe direction of the output vectors indicates the axis of rotation,\nand their magnitude represents the rotational strength at each voxel."
      }
    ]
  },
  "GeometryNodeGridLaplacian": {
    "label": "Grid Laplacian Node",
    "description": "The *Grid Laplacian* node computes the Laplacian of a scalar voxel grid.\nThe Laplacian measures how a value at each voxel differs from the average\nof its neighbors\u2014essentially, how much the field \"curves\" or deviates locally.\nMathematically, the Laplacian is defined as the divergence of the gradient\nof a scalar field. It is commonly used in physics and geometry for diffusion,\nsmoothing, curvature analysis, and solving partial differential equations.\nFor a scalar field f(x, y, z), the Laplacian \\nabla^2 f\nis given by:\n\\nabla^2 f = \\nabla f =\n\\frac{\\partial^2 f}{\\partial x^2} +\n\\frac{\\partial^2 f}{\\partial y^2} +\n\\frac{\\partial^2 f}{\\partial z^2}\nThe Laplacian is positive where the field has a local minimum (value smaller\nthan its surroundings) and negative where it has a local maximum (value\nlarger than its surroundings).",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/sample/grid_laplacian.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input scalar grid on which to compute the Laplacian.\nThe grid must store scalar (float) values such as density, temperature,\nor a signed distance field."
      }
    ],
    "outputs": [
      {
        "name": "Laplacian",
        "description": "A float grid representing the Laplacian of the input field.\nEach voxel contains the sum of the second derivatives of the input\nfield along the X, Y, and Z axes. This can be used to detect local\npeaks and valleys or to drive smoothing and diffusion effects in\nprocedural grids."
      }
    ]
  },
  "GeometryNodeSampleGrid": {
    "label": "Sample Grid Node",
    "description": "The *Sample Grid* node retrieves values from a voxel grid at given positions in space.\nIt evaluates the grid's stored data (such as float, integer, boolean, or vector values)\nand returns the interpolated result for each queried position.\nThis node is useful for reading data from grids created by other nodes\n(e.g. *Mesh to SDF Grid*, *Field to Grid*, or *Points to SDF Grid*) and using\nthose values to drive procedural effects, geometry deformation, or shading.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/sample/sample_grid.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input grid to sample from. The grid can store scalar, vector, or\ncolor data depending on its data type."
      },
      {
        "name": "Position",
        "description": "The spatial positions (in object space) where the grid values are\nevaluated. Each position is interpolated based on nearby voxel values."
      },
      {
        "name": "Interpolation",
        "description": "The interpolation method used to compute the sampled value between\nneighboring voxels:\nReturns the value from the closest voxel without interpolation.\nFastest method but can appear blocky or discrete.\nPerforms linear interpolation across the eight nearest voxels.\nProduces smooth transitions between samples and is suitable for most general uses.\nUses a higher-order (quadratic) interpolation for even smoother\ngradients and more continuous results, at the cost of additional computation."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "The interpolated value sampled from the grid at the given positions.\nThe output type matches the *Data Type* of the input grid."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid (e.g. *Float*, *Integer*, *Boolean*, or *Vector*).\nDetermines the output socket type of the node."
  },
  "GeometryNodeGridDivergence": {
    "label": "Grid Divergence Node",
    "description": "The *Grid Divergence* node computes the divergence of a vector field stored\nin a voxel grid. Divergence measures how much a field is \"spreading out\" or\n\"converging\" at each point, representing the net flow entering or leaving a\nvoxel.\nA positive divergence value indicates that the field is expanding outward\nfrom that voxel (acting as a source), while a negative value indicates that the\nfield is converging inward (acting as a sink). A divergence near zero means\nthe field is locally balanced, with equal flow in and out.\nThis operator is commonly used in fluid and smoke simulation workflows, where\nit helps enforce incompressibility or visualize the flow behavior of vector\nfields such as velocity grids.\nMathematically, for a 3D vector field \\mathbf{F} = (F_x, F_y, F_z),\nthe divergence is defined as:\n\\nabla \\cdot \\mathbf{F} =\n\\frac{\\partial F_x}{\\partial x} +\n\\frac{\\partial F_y}{\\partial y} +\n\\frac{\\partial F_z}{\\partial z}",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/sample/grid_divergence.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input vector grid whose divergence will be calculated.\nThe grid must store 3D vector values, such as a velocity or directional\nfield."
      }
    ],
    "outputs": [
      {
        "name": "Divergence",
        "description": "A float grid representing the divergence of the input field.\nPositive values correspond to regions where vectors spread apart (sources),\nwhile negative values represent regions where vectors converge (sinks)."
      }
    ]
  },
  "GeometryNodeGridGradient": {
    "label": "Grid Gradient Node",
    "description": "The *Grid Gradient* node calculates the gradient of a scalar voxel grid.\nThe gradient is a vector field that describes both the direction and rate of\nthe steepest increase in the grid's values at each voxel.\nIn other words, it shows how and where the scalar quantity (such as density,\ntemperature, or distance) changes in 3D space. The direction of the gradient\nvector points toward increasing values, and its magnitude represents how\nquickly the value changes in that direction.\nMathematically, for a scalar field f(x, y, z), the gradient is defined as:\n\\nabla f =\n\\frac{\\partial f}{\\partial x} \\mathbf{\\hat{i}} +\n\\frac{\\partial f}{\\partial y} \\mathbf{\\hat{j}} +\n\\frac{\\partial f}{\\partial z} \\mathbf{\\hat{k}}\nThis operation is often used in procedural modeling or simulation workflows\nto derive direction fields from scalar quantities, such as computing surface\nnormals from a signed distance field (SDF) or determining the flow direction\nin density or temperature fields.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/sample/grid_gradient.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input grid from which to compute the gradient.\nThe grid must contain float values, such as density or distance."
      }
    ],
    "outputs": [
      {
        "name": "Gradient",
        "description": "A vector grid representing the gradient of the input field.\nEach vector points toward the direction of greatest increase in the scalar\nvalue, with its length corresponding to the rate of change."
      }
    ]
  },
  "GeometryNodeGridAdvect": {
    "label": "Advect Grid Node",
    "description": "The *Advect Grid* node moves voxel values through a velocity field over time\nusing numerical integration. This operation is called *advection* and is\ncommonly used in fluid, smoke, and motion simulation systems to evolve\nquantities such as density, temperature, or color according to a flow field.\nThe node supports multiple integration schemes that trade off between speed,\naccuracy, and numerical stability. It can be used for both scalar and vector\ngrids, provided the voxel size is uniform across the domain.\nAdvection is conceptually equivalent to tracing each voxel backward through the\nvelocity field by a small time step, sampling the grid value from the previous\nlocation, and assigning that value to the current voxel.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/sample/advect_grid.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input grid to advect. Must have a uniform voxel scale."
      },
      {
        "name": "Velocity",
        "description": "The vector grid defining the flow direction and magnitude at each voxel.\nThe *Velocity* field determines how grid values are transported through\nspace."
      },
      {
        "name": "Time Step",
        "description": "The time step used for advection, in seconds.\nLarger values result in faster motion but may reduce accuracy or stability."
      },
      {
        "name": "Integration Scheme",
        "description": "The numerical integration method used to trace voxel positions through the\nvelocity field:\nFirst-order semi-Lagrangian integration. Fastest and most stable but\nintroduces noticeable numerical diffusion (blurring).\nSecond-order midpoint integration. Balances speed and accuracy, suitable\nfor most cases.\nThird-order Runge-Kutta integration. Provides higher accuracy with\nmoderate computational cost.\nFourth-order Runge-Kutta integration. Highest accuracy single-step\nscheme, ideal for detailed simulations but slower to compute.\nMacCormack scheme with implicit diffusion control. Reduces numerical\ndissipation while maintaining stability.\nBack and Forth Error Compensation and Correction. An advanced scheme that\nminimizes dissipation and maintains sharper features."
      },
      {
        "name": "Limiter",
        "description": "The limiting strategy used to reduce overshoot or undershoot artifacts\nin high-order advection schemes:\nNo limiting applied. Fastest but can introduce artifacts in regions with\nsteep gradients.\nClamps values to the range of the original neighborhood, preventing\novershooting and undershooting while preserving stability.\nReverts to first-order integration in cases where clamping would be\nnecessary. More conservative and stable than clamping alone."
      }
    ],
    "outputs": [
      {
        "name": "Grid",
        "description": "The resulting grid after advection. Each voxel value has been transported\naccording to the specified velocity field and integration scheme.\nThe result represents the grid state after the given *Time Step* has elapsed."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid (e.g. *Float*, *Integer*, *Vector*).\nDetermines the kind of field being advected."
  },
  "GeometryNodeSampleGridIndex": {
    "label": "Sample Grid Index Node",
    "description": "The *Sample Grid Index* node retrieves values directly from a voxel grid at\nspecific voxel indices rather than at arbitrary spatial positions.\nUnlike the Sample Grid\nnode, which interpolates between voxels in object space, this node reads the\nexact stored value of the voxel located at the specified integer coordinates.\nThis makes it useful for working in *index space*, for example when performing\nvoxel neighborhood lookups, procedural filtering, or sampling based on values\nfrom the Voxel Index node.",
    "source": "_archive/blender-manual-gn/manual/modeling/geometry_nodes/volume/sample/sample_grid_index.rst",
    "inputs": [
      {
        "name": "Grid",
        "description": "The input voxel grid to sample values from. The grid may store scalar,\nvector, color, or boolean data depending on its data type."
      },
      {
        "name": "X, Y, Z",
        "description": "The integer voxel coordinates in grid index space to sample from.\nEach coordinate specifies which voxel to retrieve the value from along its respective axis."
      }
    ],
    "outputs": [
      {
        "name": "Value",
        "description": "The voxel value retrieved at the specified grid indices.\nThe output type matches the grid's *Data Type*. No interpolation is\nperformed\u2014values are sampled exactly as stored in the grid."
      }
    ],
    "properties": "Data Type\nThe type of data stored in the grid (e.g. *Float*, *Integer*, *Boolean*, or *Vector*).\nDetermines both the expected data type of the *Grid* input and the type of the *Value* output."
  }
}